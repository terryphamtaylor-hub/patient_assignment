<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Assignment App</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet" />
    <style>
        /* Generated Tailwind CSS */
        :root { --tw-border-opacity: 1; --tw-shadow: 0 0 #0000; --tw-shadow-colored: 0 0 #0000; }
        *, ::before, ::after { box-sizing: border-box; border-width: 0; border-style: solid; border-color: #e5e7eb; }
        html { line-height: 1.5; -webkit-text-size-adjust: 100%; -moz-tab-size: 4; tab-size: 4; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; }
        body { margin: 0; line-height: inherit; font-family: 'Inter', sans-serif; }
        h1, h2, h3, p, ul { margin: 0; padding: 0; }
        button { font-family: inherit; font-size: 100%; font-weight: inherit; line-height: inherit; color: inherit; margin: 0; padding: 0; text-transform: none; background-color: transparent; background-image: none; cursor: pointer; }
        input, select, textarea { font-family: inherit; font-size: 100%; font-weight: inherit; line-height: inherit; color: inherit; margin: 0; padding: 0; border-radius: 0; }
        svg { display: block; vertical-align: middle; }
        .border { border-width: 1px; }
        .border-b { border-bottom-width: 1px; }
        .border-t { border-top-width: 1px; }
        .border-gray-200 { border-color: #e5e7eb; }
        .border-gray-300 { border-color: #d1d5db; }
        .border-green-200 { border-color: #bbf7d0; }
        .border-indigo-200 { border-color: #c7d2fe; }
        .bg-blue-50 { background-color: #eff6ff; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .bg-green-50 { background-color: #f0fdf4; }
        .bg-indigo-50 { background-color: #eef2ff; }
        .bg-white { background-color: #fff; }
        .bg-yellow-100 { background-color: #fef9c3; }
        .bg-yellow-200 { background-color: #fef08a; }
        .p-0\.5 { padding: 0.125rem; }
        .p-3 { padding: 0.75rem; }
        .p-4 { padding: 1rem; }
        .p-6 { padding: 1.5rem; }
        .pb-2 { padding-bottom: 0.5rem; }
        .px-1 { padding-left: 0.25rem; padding-right: 0.25rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .py-0\.5 { padding-top: 0.125rem; padding-bottom: 0.125rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .pt-1 { padding-top: 0.25rem; }
        .pt-2 { padding-top: 0.5rem; }
        .font-sans { font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-4xl { font-size: 2.25rem; line-height: 2.5rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-xs { font-size: 0.75rem; line-height: 1rem; }
        .font-bold { font-weight: 700; }
        .font-medium { font-weight: 500; }
        .font-semibold { font-weight: 600; }
        .text-blue-600 { color: #2563eb; }
        .text-blue-700 { color: #1d4ed8; }
        .text-blue-800 { color: #1e40af; }
        .text-gray-500 { color: #6b7280; }
        .text-gray-600 { color: #4b5563; }
        .text-gray-700 { color: #374151; }
        .text-gray-800 { color: #1f2937; }
        .text-green-600 { color: #16a34a; }
        .text-green-700 { color: #15803d; }
        .text-indigo-700 { color: #4338ca; }
        .text-indigo-800 { color: #3730a3; }
        .text-red-600 { color: #dc2626; }
        .text-yellow-800 { color: #854d0e; }
        .shadow-md { --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow); }
        .focus\:ring-blue-500:focus { --tw-ring-color: #3b82f6; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
        .btn-primary { background-color: #2563eb; color: white; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); transition: background-color 0.15s ease-in-out; }
        .btn-primary:hover { background-color: #1d4ed8; }
        .btn-primary:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .btn-secondary { background-color: #dc2626; color: white; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); transition: background-color 0.15s ease-in-out; }
        .btn-secondary:hover { background-color: #b91c1c; }
        .btn-neutral { background-color: #6b7280; color: white; font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.5rem; box-shadow: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px 0 rgba(0,0,0,0.06); transition: background-color 0.15s ease-in-out; }
        .btn-neutral:hover { background-color: #4b5563; }
        .btn-neutral:disabled { background-color: #9ca3af; cursor: not-allowed; }
        .btn-small-action { padding: 0.25rem 0.5rem; font-size: 0.875rem; }
        .input-field { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: inset 0 1px 2px 0 rgba(0,0,0,0.05); }
        .compact-input { width: 4rem; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; box-shadow: inset 0 1px 2px 0 rgba(0,0,0,0.05); }
        .label-text { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; font-weight: 500; color: #374151; }
        .checkbox-label { display: flex; align-items: center; font-size: 0.875rem; color: #374151; }
        .checkbox-label input { margin-right: 0.5rem; height: 1rem; width: 1rem; }
        .modal-backdrop { position: fixed; inset: 0; background-color: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 50; padding: 1rem; display: none; }
        .modal-content { background-color: white; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -2px rgba(0,0,0,0.05); width: 100%; text-align: center; max-height: 90vh; overflow-y: auto; }
        .modal-content.md { max-width: 28rem; }
        .modal-content.xl { max-width: 42rem; }
        .prose { max-width: none; } 
        .textarea-large { width: 100%; min-height: 200px; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-family: monospace; font-size: 0.875rem; }
        .grid { display: grid; }
        .flex { display: flex; }
        .w-4 { width: 1rem; }
        .w-5 { width: 1.25rem; }
        .w-full { width: 100%; }
        .h-4 { height: 1rem; }
        .h-5 { height: 1.25rem; }
        .max-h-60 { max-height: 15rem; }
        .max-h-96 { max-height: 24rem; }
        .min-w-0 { min-width: 0px; }
        .flex-grow { flex-grow: 1; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .items-end { align-items: flex-end; }
        .items-start { align-items: flex-start; }
        .justify-center { justify-content: center; }
        .justify-end { justify-content: flex-end; }
        .justify-between { justify-content: space-between; }
        .gap-4 { gap: 1rem; }
        .gap-8 { gap: 2rem; }
        .space-x-2 > :not([hidden]) ~ :not([hidden]) { --tw-space-x-reverse: 0; margin-right: calc(0.5rem * var(--tw-space-x-reverse)); margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse))); }
        .space-x-4 > :not([hidden]) ~ :not([hidden]) { --tw-space-x-reverse: 0; margin-right: calc(1rem * var(--tw-space-x-reverse)); margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse))); }
        .space-x-6 > :not([hidden]) ~ :not([hidden]) { --tw-space-x-reverse: 0; margin-right: calc(1.5rem * var(--tw-space-x-reverse)); margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse))); }
        .space-y-1 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(0.25rem * var(--tw-space-y-reverse)); }
        .space-y-2 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(0.5rem * var(--tw-space-y-reverse)); }
        .space-y-3 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(0.75rem * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(0.75rem * var(--tw-space-y-reverse)); }
        .space-y-4 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(1rem * var(--tw-space-y-reverse)); }
        .overflow-y-auto { overflow-y: auto; }
        .rounded-md { border-radius: 0.375rem; }
        .rounded-sm { border-radius: 0.125rem; }
        .rounded-xl { border-radius: 0.75rem; }
        .whitespace-pre-wrap { white-space: pre-wrap; }
        .last\:border-b-0:last-child { border-bottom-width: 0px; }
        .first\:border-t-0:first-child { border-top-width: 0px; }
        .first\:mt-0:first-child { margin-top: 0px; }
        .-ml-1 { margin-left: -0.25rem; }
        .mb-0 { margin-bottom: 0px; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mb-8 { margin-bottom: 2rem; }
        .ml-1 { margin-left: 0.25rem; }
        .ml-2 { margin-left: 0.5rem; }
        .ml-4 { margin-left: 1rem; }
        .mr-2 { margin-right: 0.5rem; }
        .mr-3 { margin-right: 0.75rem; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mt-3 { margin-top: 0.75rem; }
        .mt-4 { margin-top: 1rem; }
        .mt-6 { margin-top: 1.5rem; }
        .my-1 { margin-top: 0.25rem; margin-bottom: 0.25rem; }
        .my-4 { margin-top: 1rem; margin-bottom: 1rem; }
        .hover\:bg-gray-50:hover { background-color: #f9fafb; }
        .hover\:text-blue-700:hover { color: #1d4ed8; }
        .hover\:text-red-700:hover { color: #b91c1c; }
        @media (min-width: 768px) { .md\:col-span-2 { grid-column: span 2 / span 2; } .md\:col-span-3 { grid-column: span 3 / span 3; } .md\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); } .md\:grid-cols-5 { grid-template-columns: repeat(5, minmax(0, 1fr)); } .md\:pt-6 { padding-top: 1.5rem; } .md\:flex-row { flex-direction: row; } .md\:space-y-0 > :not([hidden]) ~ :not([hidden]) { --tw-space-y-reverse: 0; margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse))); margin-bottom: calc(0px * var(--tw-space-y-reverse)); } }
        @media (min-width: 1024px) { .lg\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); } .lg\:grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
    </style>
</head>
<body class="bg-gray-100 p-4 font-sans text-gray-800">

    <div id="app-container">
        </div>
    
    <div id="general-modal" class="modal-backdrop">
        <div id="general-modal-content" class="modal-content md">
             <p id="general-modal-message" class="text-lg font-medium mb-4 whitespace-pre-wrap"></p>
             <div id="general-modal-custom-content" class="mb-6 text-left"></div>
             <div id="general-modal-buttons" class="flex justify-center space-x-4">
                 </div>
        </div>
    </div>

    <div id="edit-teams-modal" class="modal-backdrop">
        <div class="modal-content xl">
            <h2 id="edit-team-modal-title" class="text-xl font-semibold mb-4">Edit Team</h2>
            <div class="space-y-3 text-left border p-4 rounded-md mb-4 bg-gray-50">
                <div> <label class="label-text">Team Name:</label> <input type="text" id="main-modal-teamName" class="input-field" /> </div>
                <div> <label class="label-text">Starting Patient Count:</label> <input type="number" id="main-modal-startingPatientCount" class="input-field" min="0" /> </div>
                <div> <label class="label-text">Preferred Locations (e.g., LocA (1), LocB (2)):</label> <input type="text" id="main-modal-preferredLocationsText" class="input-field" placeholder="Floor1 (1), ICU (2)"/> </div>
                <div> <label class="label-text">Other Locations (comma-separated):</label> <input type="text" id="main-modal-otherLocationsText" class="input-field" placeholder="ED, Clinic" /> </div>
                <div> <label class="label-text">Avoid Locations (comma-separated):</label> <input type="text" id="main-modal-avoidLocationsText" class="input-field" placeholder="FloorX, WardY" /> </div>
                <div class="flex items-center space-x-6">
                    <div class="flex items-center"> <input type="checkbox" id="main-modal-prefersGynPatients" class="h-4 w-4 mr-2"/> <label for="main-modal-prefersGynPatients" class="label-text mb-0">Prefers Gyn Patients</label> </div>
                    <div class="flex items-center"> <input type="checkbox" id="main-modal-prefersSarcomaPatients" class="h-4 w-4 mr-2"/> <label for="main-modal-prefersSarcomaPatients" class="label-text mb-0">Prefers Sarcoma Patients</label> </div>
                </div>
                <div class="flex items-center"> <input type="checkbox" id="main-modal-lowCap" class="h-4 w-4 mr-2"/> <label for="main-modal-lowCap" class="label-text mb-0">Low Cap (Max 11 Patients)</label> </div>
                <div> <label class="label-text">Other Preferences/Notes:</label> <textarea id="main-modal-otherPreferences" class="input-field" rows="2"></textarea> </div>
                 <div class="flex space-x-2 mt-3">
                     <button onclick="saveTeamFromMainModal()" class="btn-primary">Save Team</button>
                     <button id="main-modal-delete-btn" onclick="confirmDeleteTeamFromMainModal()" class="btn-secondary">Delete This Team</button>
                     <button onclick="clearMainModalForm()" class="btn-neutral">Clear Form / Add New</button>
                 </div>
            </div>
            <hr class="my-4"/>
            <h3 class="text-lg font-semibold mb-2">Manage Existing Teams List</h3>
            <div id="main-modal-teams-list" class="max-h-60 overflow-y-auto text-left space-y-1"></div>
            <div class="mt-6 flex flex-col sm:flex-row justify-between items-center space-y-2 sm:space-y-0">
                <div class="flex space-x-2">
                    <button onclick="loadDefaultTeamsUserAction()" class="btn-neutral" title="Deletes all current teams and loads a predefined set.">Load Default Team Set</button>
                    <button onclick="openEditDefaultTeamsModal()" class="btn-neutral">Edit Session Default Team Set</button>
                </div>
                <button onclick="closeEditTeamsModal()" class="btn-primary">Exit Manager</button>
            </div>
        </div>
    </div>

    <div id="edit-default-teams-modal" class="modal-backdrop">
        <div id="edit-default-teams-content" class="modal-content xl">
            </div>
    </div>


    <script>
    // --- SECURITY UTILITY --- //
    /**
     * Escapes HTML special characters in a string to prevent XSS attacks.
     * @param {string} str The string to escape.
     * @returns {string} The escaped string.
     */
    function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        return str.replace(/[&<>'"]/g, tag => ({
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#39;',
            '"': '&quot;'
        }[tag] || tag));
    }

    // --- STATE MANAGEMENT --- //
    // All application state is stored in these variables.
    // They are modified by functions, which then call render functions to update the UI.

    let teams = [];
    let unassignedPatients = [];
    let assignmentReportData = [];
    let teamAssignmentSummaryData = [];
    let loading = false;
    let assignmentPerformedInSession = false;

    // State for undo functionality
    let previousTeamsState = null;
    let previousUnassignedPatientsState = null;
    
    // State for the edit modals
    let editingTeamInMainModal = null; // will store the team object being edited
    let editingSingleDefaultTeam = null; // will store the default team object being edited
    
    const initialTeamFormState = {
        id: null, teamName: '', startingPatientCount: 0, preferredLocations: [],
        otherLocations: [], avoidLocations: [], prefersGynPatients: false,
        prefersSarcomaPatients: false, otherPreferences: '', lowCap: false, currentPatients: []
    };

    // This is the hardcoded default data, previously a constant in React
    const defaultTeamDataArray = [
        { teamName: 'A', preferredLocations: [{ location: 'P4', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'B', preferredLocations: [{ location: 'G21', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'C', preferredLocations: [{ location: 'G22', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'E', avoidLocations: ['G22', 'G21', 'G11', 'P4'], otherPreferences: 'Tries to avoid G22, G21, G11, P4.', startingPatientCount: 0, preferredLocations: [], otherLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false }, 
        { teamName: 'F', preferredLocations: [{ location: 'G22', priority: 2 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'G', preferredLocations: [{ location: 'G21', priority: 2 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'H', preferredLocations: [], avoidLocations: ['G22', 'G21', 'G11', 'G7'], otherPreferences: '', startingPatientCount: 0, otherLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false }, 
        { teamName: 'I', preferredLocations: [{ location: 'G7', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'J', preferredLocations: [{ location: 'G11', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'K', preferredLocations: [], avoidLocations: ['G22', 'G21', 'G11', 'G7'], otherPreferences: '', startingPatientCount: 0, otherLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'L', preferredLocations: [{ location: 'G11', priority: 2 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'N', prefersGynPatients: true, otherPreferences: 'Preferred team for Gyn patients.', startingPatientCount: 0, preferredLocations: [], otherLocations: [], avoidLocations: [], prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        { teamName: 'O', preferredLocations: [{ location: 'G21', priority: 3 }], otherPreferences: 'Preferred team for Sarcoma patients.', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: true, currentPatients: [], lowCap: false },
        { teamName: 'P', preferredLocations: [{ location: 'G22', priority: 3 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
    ];
    
    // We keep a separate copy for session edits
    let sessionDefaultTeams = JSON.parse(JSON.stringify(defaultTeamDataArray));


    // --- UTILITY FUNCTIONS --- //

    const generateId = () => crypto.randomUUID();

    const parseLocationsWithPriority = (text) => {
        if (!text || text.trim() === '') return [];
        return text.split(',').map(part => {
            part = part.trim();
            const match = part.match(/(.+)\s\((\d+)\)$/);
            return match ? { location: match[1].trim(), priority: parseInt(match[2], 10) } : { location: part, priority: 1 };
        }).filter(loc => loc.location !== '');
    };

    const formatLocationsWithPriority = (locationsArray) => {
        return (locationsArray || []).map(loc => loc.priority === 1 ? loc.location : `${loc.location} (${loc.priority})`).join(', ');
    };
    
    // --- CORE LOGIC FUNCTIONS (Assignment Algorithm) --- //
    // These functions are largely unchanged from the React version, operating on arrays and objects directly.
    const findBestTeamForPatient = (patient, availableTeams, rules, allTeamsForLoadBalancing) => {
        let bestTeam = null;
        let highestScore = -Infinity;

        for (const team of availableTeams) {
            const currentPatientSlotsFilled = team.startingPatientCount + team.currentPatientsThisSession.length;
            if (currentPatientSlotsFilled >= team.cap && !(team.cap === 16 && currentPatientSlotsFilled === 15 && patient.needsHAndP)) {
                continue;
            }

            let score = 0;

            if (rules.phase === 'sarcoma') {
                if (patient.patientType?.toLowerCase() === 'sarcoma' && team.prefersSarcomaPatients) score += 1000;
            }
            if (rules.phase === 'gyn') {
                if (patient.patientType?.toLowerCase() === 'gyn' && team.prefersGynPatients) score += 1000;
            }
            if (rules.phase === 'prefLoc') {
                const preferredMatch = team.preferredLocations.find(pl => pl.location === patient.currentLocation);
                if (preferredMatch) score += 500 + (5 - preferredMatch.priority);
                else continue; 
            }

            if (team.avoidLocations.includes(patient.currentLocation)) score -= rules.relaxAvoid ? 50 : 1000;
            
            if (rules.phase !== 'sarcoma' && patient.patientType?.toLowerCase() === 'sarcoma' && team.prefersSarcomaPatients) score += 100;
            if (rules.phase !== 'gyn' && patient.patientType?.toLowerCase() === 'gyn' && team.prefersGynPatients) score += 100;

            if (rules.phase !== 'prefLoc') {
                const preferredMatch = team.preferredLocations.find(pl => pl.location === patient.currentLocation);
                if (preferredMatch) score += 50 + (5 - preferredMatch.priority);
                else if (team.otherLocations.includes(patient.currentLocation)) score += 35; 
            }
            if (team.currentPatientsThisSession.some(p => p.location === patient.currentLocation)) score += 15; 

            if (patient.needsHAndP) {
                if (team.needsHAndPThisSessionCount > 0) { 
                    score -= 200; 
                    score -= team.newPatientsThisSessionCount * 10; 
                }
                if (team.cap - currentPatientSlotsFilled === 1) score += 150; 
            }

            let potentialNextTotalSlotsList = allTeamsForLoadBalancing.map(tCopy => {
                return (tCopy.startingPatientCount || 0) + 
                       tCopy.currentPatientsThisSession.length + 
                       (tCopy.id === team.id ? 1 : 0);
            });
            const minPotentialTotalSlots = Math.min(...potentialNextTotalSlotsList);
            const maxPotentialTotalSlots = Math.max(...potentialNextTotalSlotsList);
            const diffInTotalSlots = maxPotentialTotalSlots - minPotentialTotalSlots;

            if (diffInTotalSlots === 0) score += 400; 
            else if (diffInTotalSlots === 1) score += 300; 
            else if (diffInTotalSlots === 2) score += 150; 
            else score -= diffInTotalSlots * 100;

            const pointsFromThisPatient = patient.needsHAndP ? 2 : 1;
            let potentialNextAddedPointsList = allTeamsForLoadBalancing.map(tCopy => {
                return tCopy.currentLoad + (tCopy.id === team.id ? pointsFromThisPatient : 0);
            });
            const minPotentialAddedPoints = Math.min(...potentialNextAddedPointsList);
            const maxPotentialAddedPoints = Math.max(...potentialNextAddedPointsList);
            const diffInAddedPoints = maxPotentialAddedPoints - minPotentialAddedPoints;

            if (diffInAddedPoints <= 1) score += 150; 
            else if (diffInAddedPoints === 2) score += 75; 
            else score -= diffInAddedPoints * 10; 
            
            score -= team.currentLoad * 0.25; 

            if (score > highestScore) {
                highestScore = score;
                bestTeam = team;
            } else if (score === highestScore) { 
                if (!bestTeam) {
                    bestTeam = team;
                } else {
                    if (team.startingPatientCount < bestTeam.startingPatientCount) {
                        bestTeam = team;
                    } else if (team.startingPatientCount === bestTeam.startingPatientCount) {
                        if (team.currentLoad < bestTeam.currentLoad) {
                            bestTeam = team;
                        }
                    }
                }
            }
        }
        return { bestTeam, highestScore };
    };

    const getSwapPatientScore = (patient, team) => {
        let score = 0;
        const isGyn = patient.type?.toLowerCase() === 'gyn';
        const isSarcoma = patient.type?.toLowerCase() === 'sarcoma';
    
        if (isGyn) {
            if (team.prefersGynPatients) score += 20000; 
            else score -= 5000; 
        } else { 
            if (team.prefersGynPatients) score -= 500; 
        }

        if (isSarcoma) {
            if (team.prefersSarcomaPatients) score += 20000;
            else score -= 5000;
        } else {
            if (team.prefersSarcomaPatients) score -= 500;
        }
    
        const p1Match = team.preferredLocations.find(pl => pl.location === patient.location && pl.priority === 1);
        const p2Match = team.preferredLocations.find(pl => pl.location === patient.location && pl.priority === 2);
        const p3Match = team.preferredLocations.find(pl => pl.location === patient.location && pl.priority === 3);
    
        if (p1Match) {
            score += 10000;
        } else if (p2Match) {
            score += 4000;
        } else if (p3Match) {
            score += 2000;
        } else if (team.otherLocations.includes(patient.location)) {
            score += 1000;
        }
        return score;
    };
    
    const swapPhaseLogic = (teamsInput, maxSwapIterations = 3, minBenefitThreshold = 100) => {
        let teams = JSON.parse(JSON.stringify(teamsInput));
        let overallSwapMadeThisRun = false;
        console.log("Starting Swap Phase...");

        // H&P Upgrade Swap Sub-Phase
        for (let upgradeIter = 0; upgradeIter < 5; upgradeIter++) {
            let upgradeSwapMade = false;
            let bestUpgradeSwap = null;
            const singleFollowUpTeams = teams.filter(t => t.currentPatientsThisSession.length === 1 && !t.currentPatientsThisSession[0].needsHAndP);
            const potentialHnpDonorTeams = teams.filter(t => t.currentPatientsThisSession.length > 1 && t.currentPatientsThisSession.some(p => p.needsHAndP));
            if (singleFollowUpTeams.length === 0 || potentialHnpDonorTeams.length === 0) break;
            for (const targetTeam of singleFollowUpTeams) {
                const followUpPatient = targetTeam.currentPatientsThisSession[0];
                for (const donorTeam of potentialHnpDonorTeams) {
                    if (targetTeam.id === donorTeam.id) continue;
                    for (let hnpIdx = 0; hnpIdx < donorTeam.currentPatientsThisSession.length; hnpIdx++) {
                        const hnpPatient = donorTeam.currentPatientsThisSession[hnpIdx];
                        if (!hnpPatient.needsHAndP) continue;
                        if (donorTeam.avoidLocations.includes(followUpPatient.location) || targetTeam.avoidLocations.includes(hnpPatient.location)) continue;
                        if (hnpPatient.type?.toLowerCase() === 'gyn' && donorTeam.prefersGynPatients && !targetTeam.prefersGynPatients) continue;
                        if (hnpPatient.type?.toLowerCase() === 'sarcoma' && donorTeam.prefersSarcomaPatients && !targetTeam.prefersSarcomaPatients) continue;
                        if (followUpPatient.type?.toLowerCase() === 'gyn' && targetTeam.prefersGynPatients && !donorTeam.prefersGynPatients) continue;
                        if (followUpPatient.type?.toLowerCase() === 'sarcoma' && targetTeam.prefersSarcomaPatients && !donorTeam.prefersSarcomaPatients) continue;
                        if (donorTeam.preferredLocations.some(pl => pl.location === hnpPatient.location && pl.priority === 1) && !targetTeam.preferredLocations.some(pl => pl.location === hnpPatient.location && pl.priority === 1)) continue;
                        if (targetTeam.preferredLocations.some(pl => pl.location === followUpPatient.location && pl.priority === 1) && !donorTeam.preferredLocations.some(pl => pl.location === followUpPatient.location && pl.priority === 1)) continue;
                        bestUpgradeSwap = { targetTeamId: targetTeam.id, donorTeamId: donorTeam.id, hnpPatientIndex: hnpIdx, fuName: followUpPatient.name, hnpName: hnpPatient.name, targetTeamName: targetTeam.teamName, donorTeamName: donorTeam.teamName, };
                        break; 
                    }
                    if (bestUpgradeSwap) break; 
                }
                if (bestUpgradeSwap) break;
            }
            if (bestUpgradeSwap) {
                const targetTeam = teams.find(t => t.id === bestUpgradeSwap.targetTeamId);
                const donorTeam = teams.find(t => t.id === bestUpgradeSwap.donorTeamId);
                const followUpData = targetTeam.currentPatientsThisSession[0];
                const hnpData = donorTeam.currentPatientsThisSession[bestUpgradeSwap.hnpPatientIndex];
                targetTeam.currentPatientsThisSession[0] = hnpData;
                donorTeam.currentPatientsThisSession[bestUpgradeSwap.hnpPatientIndex] = followUpData;
                targetTeam.needsHAndPThisSessionCount = 1;
                donorTeam.needsHAndPThisSessionCount = donorTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                upgradeSwapMade = true;
                overallSwapMadeThisRun = true;
            }
            if (!upgradeSwapMade) break;
        }

        // H&P Downgrade Swap Sub-Phase
        for (let downgradeIter = 0; downgradeIter < 5; downgradeIter++) {
            let downgradeSwapMade = false;
            let bestDowngradeSwap = null;
            const potentialDowngradeTeams = teams.filter(t => t.currentPatientsThisSession.length >= 2 && t.currentPatientsThisSession.some(p => p.needsHAndP));
            const potentialUpgradeTeams = teams.filter(t => t.currentPatientsThisSession.length === 1 && !t.currentPatientsThisSession[0].needsHAndP);
            if (potentialDowngradeTeams.length === 0 || potentialUpgradeTeams.length === 0) break;
            for (const downgradingTeam of potentialDowngradeTeams) {
                for (const upgradingTeam of potentialUpgradeTeams) {
                    if (downgradingTeam.id === upgradingTeam.id) continue;
                    const followUpPatient = upgradingTeam.currentPatientsThisSession[0];
                    for (let hnpIdx = 0; hnpIdx < downgradingTeam.currentPatientsThisSession.length; hnpIdx++) {
                        const hnpPatient = downgradingTeam.currentPatientsThisSession[hnpIdx];
                        if (!hnpPatient.needsHAndP) continue;
                        if (hnpPatient.type?.toLowerCase() === 'gyn' && downgradingTeam.prefersGynPatients && !upgradingTeam.prefersGynPatients) continue;
                        if (hnpPatient.type?.toLowerCase() === 'sarcoma' && downgradingTeam.prefersSarcomaPatients && !upgradingTeam.prefersSarcomaPatients) continue;
                        if (followUpPatient.type?.toLowerCase() === 'gyn' && upgradingTeam.prefersGynPatients && !downgradingTeam.prefersGynPatients) continue;
                        if (followUpPatient.type?.toLowerCase() === 'sarcoma' && upgradingTeam.prefersSarcomaPatients && !downgradingTeam.prefersSarcomaPatients) continue;
                        if (downgradingTeam.preferredLocations.some(pl => pl.location === hnpPatient.location && pl.priority === 1) && !upgradingTeam.preferredLocations.some(pl => pl.location === hnpPatient.location && pl.priority === 1)) continue;
                        if (upgradingTeam.preferredLocations.some(pl => pl.location === followUpPatient.location && pl.priority === 1) && !downgradingTeam.preferredLocations.some(pl => pl.location === followUpPatient.location && pl.priority === 1)) continue;
                        bestDowngradeSwap = { downgradingTeamId: downgradingTeam.id, upgradingTeamId: upgradingTeam.id, hnpPatientIndex: hnpIdx, fuName: followUpPatient.name, hnpName: hnpPatient.name, downgradingTeamName: downgradingTeam.teamName, upgradingTeamName: upgradingTeam.teamName };
                        break; 
                    }
                    if (bestDowngradeSwap) break; 
                }
                if (bestDowngradeSwap) break;
            }
            if (bestDowngradeSwap) {
                const downgradingTeam = teams.find(t => t.id === bestDowngradeSwap.downgradingTeamId);
                const upgradingTeam = teams.find(t => t.id === bestDowngradeSwap.upgradingTeamId);
                const hnpData = downgradingTeam.currentPatientsThisSession[bestDowngradeSwap.hnpPatientIndex];
                const followUpData = upgradingTeam.currentPatientsThisSession[0];
                downgradingTeam.currentPatientsThisSession[bestDowngradeSwap.hnpPatientIndex] = followUpData;
                upgradingTeam.currentPatientsThisSession[0] = hnpData;
                downgradingTeam.needsHAndPThisSessionCount = downgradingTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                upgradingTeam.needsHAndPThisSessionCount = upgradingTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                downgradeSwapMade = true;
                overallSwapMadeThisRun = true;
            }
            if (!downgradeSwapMade) break;
        }

        // General Preference Swap Phase
        for (let iter = 0; iter < maxSwapIterations; iter++) {
            let swapMadeInThisIteration = false;
            let bestSwapCandidate = null; 
            for (let i = 0; i < teams.length; i++) { 
                for (let j = i + 1; j < teams.length; j++) { 
                    const teamA = teams[i];
                    const teamB = teams[j];
                    for (let p1Idx = 0; p1Idx < teamA.currentPatientsThisSession.length; p1Idx++) {
                        const patient1 = teamA.currentPatientsThisSession[p1Idx];
                        for (let p2Idx = 0; p2Idx < teamB.currentPatientsThisSession.length; p2Idx++) {
                            const patient2 = teamB.currentPatientsThisSession[p2Idx];
                            if (patient1.needsHAndP !== patient2.needsHAndP) continue;
                            if (teamB.avoidLocations.includes(patient1.location) || teamA.avoidLocations.includes(patient2.location)) continue;
                            if (patient1.type?.toLowerCase() === 'gyn' && teamA.prefersGynPatients && !teamB.prefersGynPatients) continue;
                            if (patient2.type?.toLowerCase() === 'gyn' && teamB.prefersGynPatients && !teamA.prefersGynPatients) continue;
                            if (patient1.type?.toLowerCase() === 'sarcoma' && teamA.prefersSarcomaPatients && !teamB.prefersSarcomaPatients) continue;
                            if (patient2.type?.toLowerCase() === 'sarcoma' && teamB.prefersSarcomaPatients && !teamA.prefersSarcomaPatients) continue;
                            const p1_on_TeamA_is_P1 = teamA.preferredLocations.some(pl => pl.location === patient1.location && pl.priority === 1);
                            const p1_on_TeamB_is_P1 = teamB.preferredLocations.some(pl => pl.location === patient1.location && pl.priority === 1);
                            if (p1_on_TeamA_is_P1 && !p1_on_TeamB_is_P1) continue;
                            const p2_on_TeamB_is_P1 = teamB.preferredLocations.some(pl => pl.location === patient2.location && pl.priority === 1);
                            const p2_on_TeamA_is_P1 = teamA.preferredLocations.some(pl => pl.location === patient2.location && pl.priority === 1);
                            if (p2_on_TeamB_is_P1 && !p2_on_TeamA_is_P1) continue;
                            const currentScoreP1 = getSwapPatientScore(patient1, teamA);
                            const currentScoreP2 = getSwapPatientScore(patient2, teamB);
                            const potentialScoreP1onB = getSwapPatientScore(patient1, teamB);
                            const potentialScoreP2onA = getSwapPatientScore(patient2, teamA);
                            const netBenefit = (potentialScoreP1onB + potentialScoreP2onA) - (currentScoreP1 + currentScoreP2);
                            if (netBenefit > (bestSwapCandidate ? bestSwapCandidate.benefit : minBenefitThreshold -1) ) {
                                bestSwapCandidate = { teamAIdx: i, p1Idx: p1Idx, teamBIdx: j, p2Idx: p2Idx, benefit: netBenefit, p1Name: patient1.name, p2Name: patient2.name, tAName: teamA.teamName, tBName: teamB.teamName };
                            }
                        }
                    }
                }
            }
            if (bestSwapCandidate) {
                const { teamAIdx, p1Idx, teamBIdx, p2Idx } = bestSwapCandidate;
                const patient1Data = teams[teamAIdx].currentPatientsThisSession[p1Idx];
                const patient2Data = teams[teamBIdx].currentPatientsThisSession[p2Idx];
                teams[teamAIdx].currentPatientsThisSession[p1Idx] = patient2Data;
                teams[teamBIdx].currentPatientsThisSession[p2Idx] = patient1Data;
                teams[teamAIdx].needsHAndPThisSessionCount = teams[teamAIdx].currentPatientsThisSession.filter(p => p.needsHAndP).length;
                teams[teamBIdx].needsHAndPThisSessionCount = teams[teamBIdx].currentPatientsThisSession.filter(p => p.needsHAndP).length;
                swapMadeInThisIteration = true;
                overallSwapMadeThisRun = true;
                iter = -1; 
            }
            if (!swapMadeInThisIteration && iter > -1) break; 
        }

        return teams;
    };

    const fillUnderutilizedTeamsPhase = (teamsInput, capUtilizationThreshold = 0.6, maxHAndPProportion = 0.4, maxFillIterations = 5) => {
        let teams = JSON.parse(JSON.stringify(teamsInput));
        let overallMoveMadeInRun = false;
        for (let fillIter = 0; fillIter < maxFillIterations; fillIter++) {
            let moveMadeThisPass = false;
            teams.forEach(team => { team.totalSlots = (team.startingPatientCount || 0) + team.currentPatientsThisSession.length; });
            const underutilizedTeams = teams.filter(t => t.totalSlots < t.cap && (t.totalSlots / t.cap) < capUtilizationThreshold).sort((a, b) => (a.totalSlots / a.cap) - (b.totalSlots / b.cap)); 
            const potentialDonorTeams = teams.filter(t => !underutilizedTeams.find(ut => ut.id === t.id) && t.currentPatientsThisSession.length > 0).sort((a, b) => b.totalSlots - a.totalSlots); 
            if (underutilizedTeams.length === 0 || potentialDonorTeams.length === 0) break; 
            for (const targetTeam of underutilizedTeams) {
                if (targetTeam.totalSlots >= targetTeam.cap) continue;
                let bestPatientToMoveFromAnyDonor = null; 
                for (const donorTeam of potentialDonorTeams) {
                    if (donorTeam.id === targetTeam.id || donorTeam.currentPatientsThisSession.length === 0) continue;
                    const avgSlots = teams.reduce((sum, t) => sum + t.totalSlots, 0) / teams.length;
                    if (donorTeam.totalSlots <= targetTeam.totalSlots + 1 && !(donorTeam.totalSlots > avgSlots && targetTeam.totalSlots < avgSlots) ) continue;
                    for (let pIdx = 0; pIdx < donorTeam.currentPatientsThisSession.length; pIdx++) {
                        const patient = donorTeam.currentPatientsThisSession[pIdx];
                        let moveScore = 0; 
                        if (targetTeam.avoidLocations.includes(patient.location) || targetTeam.totalSlots + 1 > targetTeam.cap) continue;
                        const isGyn = patient.type?.toLowerCase() === 'gyn', isSarcoma = patient.type?.toLowerCase() === 'sarcoma';
                        if (isGyn && donorTeam.prefersGynPatients && !targetTeam.prefersGynPatients) moveScore -= 10000;
                        else if (isGyn && !donorTeam.prefersGynPatients && targetTeam.prefersGynPatients) moveScore += 5000;
                        else if (isGyn && donorTeam.prefersGynPatients && targetTeam.prefersGynPatients) moveScore += 1000;
                        if (isSarcoma && donorTeam.prefersSarcomaPatients && !targetTeam.prefersSarcomaPatients) moveScore -= 10000;
                        else if (isSarcoma && !donorTeam.prefersSarcomaPatients && targetTeam.prefersSarcomaPatients) moveScore += 5000;
                        else if (isSarcoma && donorTeam.prefersSarcomaPatients && targetTeam.prefersSarcomaPatients) moveScore += 1000;
                        const donorHasPref = donorTeam.preferredLocations.some(pl => pl.location === patient.location), targetHasPref = targetTeam.preferredLocations.some(pl => pl.location === patient.location);
                        if (donorHasPref && !targetHasPref) moveScore -= 2000;
                        else if (!donorHasPref && targetHasPref) moveScore += 1000;
                        const donorHasOther = donorTeam.otherLocations.includes(patient.location), targetHasOther = targetTeam.otherLocations.includes(patient.location);
                        if(donorHasOther && !targetHasOther && !targetHasPref) moveScore -=500;
                        else if(!donorHasOther && targetHasOther) moveScore += 250;
                        if (patient.needsHAndP) {
                            const currentHPsOnTarget = targetTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                            const projectedHPProportionOnTarget = (currentHPsOnTarget + 1) / (targetTeam.totalSlots + 1);
                            if (projectedHPProportionOnTarget > maxHAndPProportion && currentHPsOnTarget >=1 ) moveScore -= 3000;
                            if (currentHPsOnTarget === 0) moveScore += 200;
                        }
                        if (!donorHasPref && !isGyn && !isSarcoma && !patient.needsHAndP && !donorHasOther) moveScore += 300; 
                        if (!bestPatientToMoveFromAnyDonor || moveScore > bestPatientToMoveFromAnyDonor.moveScore) {
                            bestPatientToMoveFromAnyDonor = { patient, indexInDonor: pIdx, donorTeam, targetTeam, moveScore };
                        }
                    }
                }
                if (bestPatientToMoveFromAnyDonor && bestPatientToMoveFromAnyDonor.moveScore > -1000) { 
                    const { patient, indexInDonor, donorTeam, targetTeam: recipientTeam } = bestPatientToMoveFromAnyDonor; 
                    donorTeam.currentPatientsThisSession.splice(indexInDonor, 1);
                    recipientTeam.currentPatientsThisSession.push(patient);
                    [donorTeam, recipientTeam].forEach(t => {
                        t.totalSlots = (t.startingPatientCount || 0) + t.currentPatientsThisSession.length;
                        t.needsHAndPThisSessionCount = t.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                        t.currentLoad = t.currentPatientsThisSession.reduce((sum, p) => sum + (p.needsHAndP ? 2 : 1), 0);
                    });
                    moveMadeThisPass = true;
                    overallMoveMadeInRun = true;
                    break; 
                }
            } 
            if (moveMadeThisPass) { fillIter = -1; continue; } 
            else break; 
        } 
        teams.forEach(team => delete team.totalSlots); 
        return teams;
    };

    const equalizeFinalCountsPhase = (teamsInput, maxIterations = 10) => {
        let teams = JSON.parse(JSON.stringify(teamsInput));
        let overallMoveMadeInRun = false;
        for (let iter = 0; iter < maxIterations; iter++) {
            let moveMadeInIteration = false;
            teams.forEach(team => {
                team.cap = team.lowCap ? 11 : 16;
                team.currentTotalSlots = (team.startingPatientCount || 0) + team.currentPatientsThisSession.length;
                team.slotsFromCap = team.cap - team.currentTotalSlots;
                team.needsHAndPThisSessionCount = team.currentPatientsThisSession.filter(p => p.needsHAndP).length;
            });
            const nonLowCapTeams = teams.filter(t => !t.lowCap);
            if (nonLowCapTeams.length <= 1) break;
            const nonLowCapSlotsFromCap = nonLowCapTeams.map(t => t.slotsFromCap);
            const minSlotsFromCap = Math.min(...nonLowCapSlotsFromCap);
            const maxSlotsFromCap = Math.max(...nonLowCapSlotsFromCap);
            if (maxSlotsFromCap - minSlotsFromCap <= 1) break;
            const potentialDonors = nonLowCapTeams.filter(t => t.slotsFromCap === minSlotsFromCap && t.currentPatientsThisSession.length > 0).sort((a, b) => a.currentLoad - b.currentLoad);
            const potentialRecipients = teams.filter(t => t.currentTotalSlots < t.cap && ((!t.lowCap && t.slotsFromCap === maxSlotsFromCap) || (t.lowCap))).sort((a, b) => b.slotsFromCap - a.slotsFromCap);
            if (potentialDonors.length === 0 || potentialRecipients.length === 0) break;
            let bestMoveDetails = null;
            let highestMovePriority = -Infinity;
            donorLoop:
            for (const currentDonor of potentialDonors) {
                recipientLoop:
                for (const currentRecipient of potentialRecipients) {
                    if (currentDonor.id === currentRecipient.id || currentRecipient.currentTotalSlots >= currentRecipient.cap) continue;
                    for (let pIdx = 0; pIdx < currentDonor.currentPatientsThisSession.length; pIdx++) {
                        const patient = currentDonor.currentPatientsThisSession[pIdx];
                        let currentMovePriority = 50000;
                        if (patient.needsHAndP) {
                            if (currentRecipient.needsHAndPThisSessionCount >= 2) { currentMovePriority = -Infinity; break; }
                            else currentMovePriority += 2000;
                        }
                        if (currentMovePriority === -Infinity) continue;
                        const isGyn = patient.type?.toLowerCase() === 'gyn', isSarcoma = patient.type?.toLowerCase() === 'sarcoma';
                        if (isGyn) {
                            if (currentDonor.prefersGynPatients && !currentRecipient.prefersGynPatients) { currentMovePriority = -Infinity; break; }
                            if (!currentDonor.prefersGynPatients && currentRecipient.prefersGynPatients) currentMovePriority += 10000;
                        } else if (!currentDonor.prefersGynPatients && currentRecipient.prefersGynPatients) currentMovePriority -= 1000;
                        if(currentMovePriority === -Infinity) continue;
                        if (isSarcoma) {
                            if (currentDonor.prefersSarcomaPatients && !currentRecipient.prefersSarcomaPatients) { currentMovePriority = -Infinity; break; }
                            if (!currentDonor.prefersSarcomaPatients && currentRecipient.prefersSarcomaPatients) currentMovePriority += 10000;
                        } else if (!currentDonor.prefersSarcomaPatients && currentRecipient.prefersSarcomaPatients) currentMovePriority -= 1000;
                        if (currentMovePriority === -Infinity) continue;
                        const donorIsP1 = currentDonor.preferredLocations.some(pl => pl.location === patient.location && pl.priority === 1);
                        const recipientIsP1 = currentRecipient.preferredLocations.some(pl => pl.location === patient.location && pl.priority === 1);
                        if (!donorIsP1 && recipientIsP1) currentMovePriority += 8000;
                        const donorIsP23 = currentDonor.preferredLocations.some(pl => pl.location === patient.location && pl.priority > 1);
                        const recipientIsP23 = currentRecipient.preferredLocations.some(pl => pl.location === patient.location && pl.priority > 1);
                        if (donorIsP23 && !recipientIsP23 && !recipientIsP1) currentMovePriority -= 500;
                        else if (!donorIsP23 && recipientIsP23) currentMovePriority += 250;
                        if (currentMovePriority > highestMovePriority) {
                            highestMovePriority = currentMovePriority;
                            bestMoveDetails = { patient, indexInDonor: pIdx, donorTeam: currentDonor, recipientTeam: currentRecipient };
                        }
                    }
                    if (highestMovePriority === -Infinity && bestMoveDetails?.donorTeam.id === currentDonor.id && bestMoveDetails?.recipientTeam.id === currentRecipient.id) {
                        bestMoveDetails = null; highestMovePriority = -Infinity; continue recipientLoop;
                    }
                }
                if (highestMovePriority === -Infinity && bestMoveDetails?.donorTeam.id === currentDonor.id) {
                    bestMoveDetails = null; highestMovePriority = -Infinity; continue donorLoop;
                }
            }
            if (bestMoveDetails && highestMovePriority > -Infinity) {
                const { patient, indexInDonor, donorTeam: actualDonor, recipientTeam: actualRecipient } = bestMoveDetails;
                actualDonor.currentPatientsThisSession.splice(indexInDonor, 1);
                actualRecipient.currentPatientsThisSession.push(patient);
                [actualDonor, actualRecipient].forEach(t => {
                    t.currentTotalSlots = (t.startingPatientCount || 0) + t.currentPatientsThisSession.length;
                    t.needsHAndPThisSessionCount = t.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                    t.currentLoad = t.currentPatientsThisSession.reduce((sum, p) => sum + (p.needsHAndP ? 2 : 1), 0);
                });
                moveMadeInIteration = true;
                overallMoveMadeInRun = true;
            }
            if (!moveMadeInIteration) break;
        }
        teams.forEach(team => { delete team.currentTotalSlots; delete team.slotsFromCap; delete team.cap; });
        return teams;
    };

    const balanceNewPatientWorkloadPhase = (teamsInput, maxIterations = 5) => {
        let teams = JSON.parse(JSON.stringify(teamsInput));
        let overallMoveMade = false;
        for (let iter = 0; iter < maxIterations; iter++) {
            let moveMadeInIteration = false;
            let bestMove = null;
            let highestBenefit = 0;
            teams.forEach(team => {
                team.cap = team.lowCap ? 11 : 16;
                team.currentTotalSlots = (team.startingPatientCount || 0) + team.currentPatientsThisSession.length;
                team.newPatientCount = team.currentPatientsThisSession.length;
            });
            const nonLowCapTeams = teams.filter(t => !t.lowCap);
            for (const donor of teams) {
                for (const recipient of teams) {
                    if (donor.id === recipient.id || recipient.currentTotalSlots >= recipient.cap || donor.newPatientCount <= recipient.newPatientCount) continue;
                    let isDonorNonLowCap = nonLowCapTeams.some(t => t.id === donor.id);
                    let isRecipientNonLowCap = nonLowCapTeams.some(t => t.id === recipient.id);
                    if (isDonorNonLowCap || isRecipientNonLowCap) {
                        let tempSlots = nonLowCapTeams.map(t => {
                            let slots = t.cap - ((t.startingPatientCount || 0) + t.currentPatientsThisSession.length);
                            if (t.id === donor.id) return slots + 1;
                            if (t.id === recipient.id) return slots - 1;
                            return slots;
                        });
                        const newMax = Math.max(...tempSlots);
                        const newMin = Math.min(...tempSlots);
                        if (newMax - newMin > 1) continue;
                    }
                    const patientsToConsider = donor.currentPatientsThisSession.filter(p => !p.needsHAndP);
                    for (const patient of patientsToConsider) {
                        let moveScore = 1000;
                        if (recipient.avoidLocations.includes(patient.location)) continue;
                        const isGyn = patient.type?.toLowerCase() === 'gyn';
                        if (isGyn && donor.prefersGynPatients && !recipient.prefersGynPatients) continue;
                        const isSarcoma = patient.type?.toLowerCase() === 'sarcoma';
                        if (isSarcoma && donor.prefersSarcomaPatients && !recipient.prefersSarcomaPatients) continue;
                        if (isGyn && !donor.prefersGynPatients && recipient.prefersGynPatients) moveScore += 200;
                        if (isSarcoma && !donor.prefersSarcomaPatients && recipient.prefersSarcomaPatients) moveScore += 200;
                        const donorIsP1 = donor.preferredLocations.some(pl => pl.location === patient.location && pl.priority === 1);
                        if (donorIsP1) moveScore -= 500;
                        const recipientIsP1 = recipient.preferredLocations.some(pl => pl.location === patient.location && pl.priority === 1);
                        if (!donorIsP1 && recipientIsP1) moveScore += 400;
                        const benefit = moveScore + (donor.newPatientCount - recipient.newPatientCount) * 100;
                        if (benefit > highestBenefit) {
                            highestBenefit = benefit;
                            bestMove = { patient, donor, recipient, patientIndex: donor.currentPatientsThisSession.findIndex(p => p.originalPatientId === patient.originalPatientId) };
                        }
                    }
                }
            }
            if (bestMove) {
                const { patient, donor, recipient, patientIndex } = bestMove;
                const donorInArray = teams.find(t => t.id === donor.id);
                const recipientInArray = teams.find(t => t.id === recipient.id);
                const [movedPatient] = donorInArray.currentPatientsThisSession.splice(patientIndex, 1);
                recipientInArray.currentPatientsThisSession.push(movedPatient);
                moveMadeInIteration = true;
                overallMoveMade = true;
            }
            if (!moveMadeInIteration) break;
        }
        teams.forEach(team => { delete team.cap; delete team.currentTotalSlots; delete team.newPatientCount; });
        return teams;
    }

    const assignPatientsLogic = (currentTeams, currentUnassignedPatients) => {
        let teamsCopy = JSON.parse(JSON.stringify(currentTeams)).map(team => ({
            ...team, cap: team.lowCap ? 11 : 16, currentPatientsThisSession: [], currentLoad: 0, 
            needsHAndPThisSessionCount: 0, newPatientsThisSessionCount: 0, 
        }));
        let patientsToProcess = JSON.parse(JSON.stringify(currentUnassignedPatients));
        const newlyAssignedPatientsLog = [];
        let assignedPatientIdsThisRun = new Set(); 
        const assignPatientToTeam = (patient, team, score, phase) => {
            const teamToUpdate = teamsCopy.find(t => t.id === team.id);
            const patientDataForTeam = { name: patient.patientName, location: patient.currentLocation, type: patient.patientType || '', needsHAndP: patient.needsHAndP || false, originalPatientId: patient.id };
            teamToUpdate.currentPatientsThisSession.push(patientDataForTeam);
            teamToUpdate.newPatientsThisSessionCount += 1;
            teamToUpdate.currentLoad += (patient.needsHAndP ? 2 : 1); 
            if (patient.needsHAndP) teamToUpdate.needsHAndPThisSessionCount += 1;
            newlyAssignedPatientsLog.push({ ...patient, assignedTeamName: team.teamName, assignmentScore: score, phase });
            assignedPatientIdsThisRun.add(patient.id);
        };
        let sarcomaPatientsToProcess = patientsToProcess.filter(p => p.patientType?.toLowerCase() === 'sarcoma' && !assignedPatientIdsThisRun.has(p.id));
        sarcomaPatientsToProcess.sort((a,b) => a.patientName.localeCompare(b.patientName));
        for (const patient of sarcomaPatientsToProcess) {
            if (assignedPatientIdsThisRun.has(patient.id)) continue;
            const sarcomaPreferredTeams = teamsCopy.filter(t => t.prefersSarcomaPatients);
            if (sarcomaPreferredTeams.length > 0) {
                const result = findBestTeamForPatient(patient, sarcomaPreferredTeams, { phase: 'sarcoma', relaxAvoid: false }, teamsCopy);
                if (result.bestTeam) assignPatientToTeam(patient, result.bestTeam, result.highestScore, 'Sarcoma-Preferred');
            }
        }
        patientsToProcess = patientsToProcess.filter(p => !assignedPatientIdsThisRun.has(p.id));
        let gynPatientsToProcess = patientsToProcess.filter(p => p.patientType?.toLowerCase() === 'gyn' && !assignedPatientIdsThisRun.has(p.id));
        gynPatientsToProcess.sort((a,b) => a.patientName.localeCompare(b.patientName)); 
        for (const patient of gynPatientsToProcess) {
            if (assignedPatientIdsThisRun.has(patient.id)) continue;
            const gynPreferredTeams = teamsCopy.filter(t => t.prefersGynPatients);
            if (gynPreferredTeams.length > 0) {
                const result = findBestTeamForPatient(patient, gynPreferredTeams, { phase: 'gyn', relaxAvoid: false }, teamsCopy);
                if (result.bestTeam) assignPatientToTeam(patient, result.bestTeam, result.highestScore, 'Gyn-Preferred');
            }
        }
        patientsToProcess = patientsToProcess.filter(p => !assignedPatientIdsThisRun.has(p.id));
        let prefLocPatientsToProcess = [...patientsToProcess]; 
        prefLocPatientsToProcess.sort((a,b) => a.patientName.localeCompare(b.patientName));
        for (const patient of prefLocPatientsToProcess) {
            if (assignedPatientIdsThisRun.has(patient.id)) continue;
            const suitablePrefLocationTeams = teamsCopy.filter(team => team.preferredLocations.some(pl => pl.location === patient.currentLocation));
            if (suitablePrefLocationTeams.length > 0) {
                 const result = findBestTeamForPatient(patient, suitablePrefLocationTeams, { phase: 'prefLoc', relaxAvoid: false }, teamsCopy);
                 if (result.bestTeam) assignPatientToTeam(patient, result.bestTeam, result.highestScore, 'Preferred-Location');
            }
        }
        patientsToProcess = patientsToProcess.filter(p => !assignedPatientIdsThisRun.has(p.id)); 
        let generalPassPatients = [...patientsToProcess];
        let iterationNeeded = true;
        while(iterationNeeded && generalPassPatients.length > 0) {
            iterationNeeded = false;
            let notAssignedThisIteration = [];
            generalPassPatients.sort((a,b) => a.patientName.localeCompare(b.patientName)); 
            for (const patient of generalPassPatients) {
                if (assignedPatientIdsThisRun.has(patient.id)) continue;
                const result = findBestTeamForPatient(patient, teamsCopy, { phase: 'general', relaxAvoid: false }, teamsCopy);
                if (result.bestTeam) {
                    assignPatientToTeam(patient, result.bestTeam, result.highestScore, 'General-StrictAvoid');
                    iterationNeeded = true; 
                } else { notAssignedThisIteration.push(patient); }
            }
            generalPassPatients = notAssignedThisIteration;
        }
        patientsToProcess = generalPassPatients; 
        if (patientsToProcess.length > 0) {
            generalPassPatients = [...patientsToProcess];
            iterationNeeded = true;
            while(iterationNeeded && generalPassPatients.length > 0) {
                iterationNeeded = false;
                let notAssignedThisIteration = [];
                generalPassPatients.sort((a,b) => a.patientName.localeCompare(b.patientName));
                for (const patient of generalPassPatients) {
                    if (assignedPatientIdsThisRun.has(patient.id)) continue;
                    const result = findBestTeamForPatient(patient, teamsCopy, { phase: 'general', relaxAvoid: true }, teamsCopy);
                    if (result.bestTeam) {
                        assignPatientToTeam(patient, result.bestTeam, result.highestScore, 'General-RelaxedAvoid');
                        iterationNeeded = true;
                    } else { notAssignedThisIteration.push(patient); }
                }
                generalPassPatients = notAssignedThisIteration;
            }
            patientsToProcess = generalPassPatients; 
        }
        return { teamsWithAssignments: teamsCopy, newlyAssignedPatientsLog, remainingUnassigned: patientsToProcess };
    };

    // --- EVENT HANDLERS & ACTION FUNCTIONS --- //
    // These functions are called by user interactions (e.g., button clicks)
    
    function addPatient() {
        const patientName = document.getElementById('patientName').value.trim();
        const currentLocation = document.getElementById('patientLocation').value.trim();
        const admittingTeam = document.getElementById('admittingTeam').value.trim();
        const patientType = document.getElementById('patientType').value;
        const needsHAndP = document.getElementById('needsHAndP').checked;

        if (!patientName) { displayGeneralModal("Patient name cannot be empty."); return; }
        if (!currentLocation) { displayGeneralModal("Patient location cannot be empty."); return; }

        unassignedPatients.push({
            id: generateId(),
            patientName,
            currentLocation,
            admittingTeam: admittingTeam || 'N/A',
            patientType: patientType === 'None' ? '' : patientType,
            needsHAndP,
        });

        document.getElementById('patientName').value = '';
        document.getElementById('patientLocation').value = '';
        document.getElementById('admittingTeam').value = '';
        document.getElementById('patientType').value = 'None';
        document.getElementById('needsHAndP').checked = false;

        renderApp();
        displayGeneralModal(`Patient "${escapeHTML(patientName)}" added to unassigned list.`);
    }

    function deleteUnassignedPatient(patientId) {
        unassignedPatients = unassignedPatients.filter(p => p.id !== patientId);
        renderApp();
    }
    
    function deleteAllUnassignedPatients() {
        if (unassignedPatients.length === 0) {
            displayGeneralModal("No unassigned patients to delete.");
            return;
        }
        const action = () => {
            unassignedPatients = [];
            renderApp();
            displayGeneralModal("All unassigned patients have been deleted.");
        };
        displayGeneralModal("Are you sure you want to delete ALL unassigned patients?", action);
    }
    
    function assignPatients() {
        if (teams.length === 0) { displayGeneralModal("Add teams first."); return; }
        if (unassignedPatients.length === 0) { displayGeneralModal("No unassigned patients to assign."); return; }

        setLoadingState(true);
        assignmentReportData = [];
        teamAssignmentSummaryData = [];
        
        previousTeamsState = JSON.parse(JSON.stringify(teams));
        previousUnassignedPatientsState = JSON.parse(JSON.stringify(unassignedPatients));
        
        // Use a timeout to allow the loading spinner to render before the heavy computation starts
        setTimeout(() => {
            const result = assignPatientsLogic(teams, unassignedPatients);
            let finalTeamsState = result.teamsWithAssignments; 
            const allNewlyAssignedPatientsLog = result.newlyAssignedPatientsLog;
            const unassignedAfterRun = result.remainingUnassigned;

            if (finalTeamsState && finalTeamsState.length > 0) finalTeamsState = fillUnderutilizedTeamsPhase(finalTeamsState);
            if (finalTeamsState && finalTeamsState.length > 0) finalTeamsState = equalizeFinalCountsPhase(finalTeamsState);
            if (finalTeamsState && finalTeamsState.length > 0) finalTeamsState = balanceNewPatientWorkloadPhase(finalTeamsState);
            if (finalTeamsState && finalTeamsState.length > 0) finalTeamsState = swapPhaseLogic(finalTeamsState); 
            
            // Update the main `teams` array with the new assignments
            teams.forEach(originalTeam => {
                const finalTeamState = finalTeamsState.find(t => t.id === originalTeam.id);
                if(finalTeamState) {
                    originalTeam.currentPatients = finalTeamState.currentPatientsThisSession.map(p => ({
                        name: p.name, location: p.location, type: p.type, needsHAndP: p.needsHAndP
                    }));
                }
            });

            // Update unassigned patients list
            const assignedIds = new Set(allNewlyAssignedPatientsLog.map(p => p.id));
            unassignedPatients = unassignedPatients.filter(p => !assignedIds.has(p.id));
            
            // Create reports
            assignmentReportData = allNewlyAssignedPatientsLog.map(logEntry => ({ 
                admittingTeam: logEntry.admittingTeam || 'N/A', 
                patientName: logEntry.patientName, 
                assignedTeamName: logEntry.assignedTeamName,
                phase: logEntry.phase 
            })).sort((a,b) => { 
                if (a.admittingTeam.toLowerCase() < b.admittingTeam.toLowerCase()) return -1; 
                if (a.admittingTeam.toLowerCase() > b.admittingTeam.toLowerCase()) return 1; 
                if (a.patientName.toLowerCase() < b.patientName.toLowerCase()) return -1; 
                if (a.patientName.toLowerCase() > b.patientName.toLowerCase()) return 1; 
                return 0; 
            });

            teamAssignmentSummaryData = finalTeamsState.map(team => {
                const newlyAssignedPatientsList = team.currentPatientsThisSession;
                const newPatientsCount = newlyAssignedPatientsList.length;
                const followUpsList = newlyAssignedPatientsList.filter(p => !p.needsHAndP);
                const needsHAndPList = newlyAssignedPatientsList.filter(p => p.needsHAndP);
                const totalPatientsAfterAssignment = (team.startingPatientCount || 0) + newPatientsCount;
                let detailString = "";
                if (newPatientsCount > 0) { 
                    let parts = [];
                    if (followUpsList.length > 0) parts.push(`follow-ups: ${followUpsList.length}`);
                    if (needsHAndPList.length > 0) {
                        const hnpPatientNames = needsHAndPList.map(p => p.name).join(', ');
                        parts.push(`needs H&P: ${needsHAndPList.length} (${escapeHTML(hnpPatientNames)})`);
                    }
                    if (parts.length > 0) detailString = `, ${parts.join(', ')}`;
                }
                return { teamName: team.teamName, startingAmount: team.startingPatientCount || 0, newlyAssignedCount: newPatientsCount, totalPatients: totalPatientsAfterAssignment, detailString };
            }).sort((a,b) => a.teamName.localeCompare(b.teamName));
            
            assignmentPerformedInSession = true;
            setLoadingState(false);
            renderApp();

            const allTeamsCapped = finalTeamsState.every(team => (team.startingPatientCount + team.currentPatientsThisSession.length) >= (team.lowCap ? 11 : 16));
            if (unassignedAfterRun.length > 0) {
                const message = allTeamsCapped 
                    ? "Assignment complete. All teams appear capped. Some patients remain unassigned and may require overcapping teams or calling backup."
                    : "Assignment complete. Some patients remain unassigned:";
                 const remainingListHTML = `<ul class="text-left text-sm max-h-40 overflow-y-auto"> ${unassignedAfterRun.map(p => `<li> ${escapeHTML(p.patientName)} (${escapeHTML(p.currentLocation)}) ${p.needsHAndP ? `<span class="font-bold text-red-600"> (Needs H&P)</span>` : ''}</li>`).join('')} </ul>`;
                displayGeneralModal(message, null, remainingListHTML);
            } else {
                displayGeneralModal("All patients assigned successfully!");
            }
        }, 10); // End of setTimeout
    }

    function handleUndoAssignment() {
        if (!assignmentPerformedInSession || !previousTeamsState || !previousUnassignedPatientsState) {
            displayGeneralModal("No assignment to undo.");
            return;
        }
        teams = JSON.parse(JSON.stringify(previousTeamsState));
        unassignedPatients = JSON.parse(JSON.stringify(previousUnassignedPatientsState));
        assignmentReportData = [];
        teamAssignmentSummaryData = [];
        assignmentPerformedInSession = false;
        previousTeamsState = null;
        previousUnassignedPatientsState = null;
        renderApp();
        displayGeneralModal("Most recent assignment has been undone.");
    }
    
    function handleResetTeams() {
        const action = () => {
            teams.forEach(team => team.currentPatients = []);
            assignmentPerformedInSession = false;
            previousTeamsState = null;
            previousUnassignedPatientsState = null;
            assignmentReportData = [];
            teamAssignmentSummaryData = [];
            renderApp();
            displayGeneralModal("All teams have been reset.");
        };
        displayGeneralModal("Reset all teams? This clears current assignments for this session.", action);
    }
    
    function _loadDefaultTeamsData() {
        teams = JSON.parse(JSON.stringify(sessionDefaultTeams)).map(t => ({...t, id: generateId(), currentPatients: []}));
        assignmentPerformedInSession = false;
        assignmentReportData = [];
        teamAssignmentSummaryData = [];
        renderApp();
    }

    // --- MODAL HANDLING --- //
    
    function displayGeneralModal(message, confirmAction = null, contentHTML = null) {
        const modal = document.getElementById('general-modal');
        const messageEl = document.getElementById('general-modal-message');
        const contentEl = document.getElementById('general-modal-custom-content');
        const buttonsEl = document.getElementById('general-modal-buttons');

        messageEl.textContent = message;
        contentEl.innerHTML = contentHTML || ''; // contentHTML is now sanitized at its creation point
        buttonsEl.innerHTML = ''; // Clear previous buttons

        if (confirmAction) {
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = 'Confirm';
            confirmBtn.className = 'btn-primary';
            confirmBtn.onclick = () => {
                confirmAction();
                closeGeneralModal();
            };
            buttonsEl.appendChild(confirmBtn);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.className = 'btn-neutral';
            cancelBtn.onclick = closeGeneralModal;
            buttonsEl.appendChild(cancelBtn);
        } else {
            const okBtn = document.createElement('button');
            okBtn.textContent = 'OK';
            okBtn.className = 'btn-primary';
            okBtn.onclick = closeGeneralModal;
            buttonsEl.appendChild(okBtn);
        }
        modal.style.display = 'flex';
    }

    function closeGeneralModal() {
        document.getElementById('general-modal').style.display = 'none';
        document.getElementById('general-modal-custom-content').innerHTML = '';
    }

    function openMainEditAddModalNewTeam() {
        editingTeamInMainModal = { ...initialTeamFormState, id: generateId() };
        populateMainModalForm();
        document.getElementById('edit-teams-modal').style.display = 'flex';
    }

    function openMainEditAddModalExistingTeam(teamId) {
        editingTeamInMainModal = teams.find(t => t.id === teamId);
        populateMainModalForm();
        document.getElementById('edit-teams-modal').style.display = 'flex';
    }
    
    function closeEditTeamsModal() {
        document.getElementById('edit-teams-modal').style.display = 'none';
        editingTeamInMainModal = null;
    }

    function populateMainModalForm() {
        const titleEl = document.getElementById('edit-team-modal-title');
        const deleteBtn = document.getElementById('main-modal-delete-btn');
        
        const team = editingTeamInMainModal;
        const isNewTeam = !teams.some(t => t.id === team.id);

        titleEl.textContent = isNewTeam ? 'Add New Team' : `Edit Team: ${escapeHTML(team.teamName)}`;
        deleteBtn.style.display = isNewTeam ? 'none' : 'inline-block';
        
        document.getElementById('main-modal-teamName').value = team.teamName || '';
        document.getElementById('main-modal-startingPatientCount').value = team.startingPatientCount || 0;
        document.getElementById('main-modal-preferredLocationsText').value = formatLocationsWithPriority(team.preferredLocations);
        document.getElementById('main-modal-otherLocationsText').value = (team.otherLocations || []).join(', ');
        document.getElementById('main-modal-avoidLocationsText').value = (team.avoidLocations || []).join(', ');
        document.getElementById('main-modal-prefersGynPatients').checked = team.prefersGynPatients || false;
        document.getElementById('main-modal-prefersSarcomaPatients').checked = team.prefersSarcomaPatients || false;
        document.getElementById('main-modal-lowCap').checked = team.lowCap || false;
        document.getElementById('main-modal-otherPreferences').value = team.otherPreferences || '';
    }

    function clearMainModalForm() {
        editingTeamInMainModal = { ...initialTeamFormState, id: generateId() };
        populateMainModalForm();
    }
    
    function saveTeamFromMainModal() {
        if (!editingTeamInMainModal) return;

        const teamName = document.getElementById('main-modal-teamName').value.trim();
        if (!teamName) { displayGeneralModal("Team name cannot be empty."); return; }
        
        const teamData = {
            id: editingTeamInMainModal.id,
            teamName: teamName,
            startingPatientCount: parseInt(document.getElementById('main-modal-startingPatientCount').value, 10) || 0,
            preferredLocations: parseLocationsWithPriority(document.getElementById('main-modal-preferredLocationsText').value),
            otherLocations: document.getElementById('main-modal-otherLocationsText').value.split(',').map(loc => loc.trim()).filter(Boolean),
            avoidLocations: document.getElementById('main-modal-avoidLocationsText').value.split(',').map(loc => loc.trim()).filter(Boolean),
            prefersGynPatients: document.getElementById('main-modal-prefersGynPatients').checked,
            prefersSarcomaPatients: document.getElementById('main-modal-prefersSarcomaPatients').checked,
            lowCap: document.getElementById('main-modal-lowCap').checked,
            otherPreferences: document.getElementById('main-modal-otherPreferences').value.trim(),
            currentPatients: editingTeamInMainModal.currentPatients || []
        };
        
        const existingTeamIndex = teams.findIndex(t => t.id === teamData.id);

        if (existingTeamIndex > -1) {
            teams[existingTeamIndex] = teamData;
            displayGeneralModal(`Team "${escapeHTML(teamData.teamName)}" updated.`);
        } else {
            teams.push(teamData);
            displayGeneralModal(`Team "${escapeHTML(teamData.teamName)}" added.`);
        }
        
        teams.sort((a,b) => a.teamName.localeCompare(b.teamName));
        renderMainModalTeamsList();
        renderApp();
    }
    
    function confirmDeleteTeamFromMainModal() {
        const teamId = editingTeamInMainModal.id;
        const team = teams.find(t => t.id === teamId);
        if (!team) return;
        
        const action = () => {
            if (team.currentPatients && team.currentPatients.length > 0) {
                 team.currentPatients.forEach(patient => {
                     unassignedPatients.push({
                          id: generateId(),
                          ...patient,
                          patientName: patient.name,
                          currentLocation: patient.location,
                          admittingTeam: 'N/A (from deleted team)'
                     });
                 });
            }
            teams = teams.filter(t => t.id !== teamId);
            clearMainModalForm();
            renderMainModalTeamsList();
            renderApp();
            displayGeneralModal(`Team "${escapeHTML(team.teamName)}" deleted.`);
        };
        displayGeneralModal(`Delete team "${escapeHTML(team.teamName)}"? Assigned patients will return to unassigned list.`, action);
    }
    
    function loadDefaultTeamsUserAction() {
        const action = () => {
            _loadDefaultTeamsData();
            clearMainModalForm();
            renderMainModalTeamsList();
            displayGeneralModal("Default teams loaded!");
        };
        displayGeneralModal("Delete ALL current teams and load the default set?", action);
    }
    
    function openEditDefaultTeamsModal() {
        renderEditDefaultTeamsModal();
        document.getElementById('edit-default-teams-modal').style.display = 'flex';
    }

    function closeEditDefaultTeamsModal() {
        document.getElementById('edit-default-teams-modal').style.display = 'none';
        editingSingleDefaultTeam = null;
    }

    function startEditSingleDefaultTeam(index) {
        editingSingleDefaultTeam = { ...sessionDefaultTeams[index], originalIndex: index };
        renderEditDefaultTeamsModal();
    }

    function saveIndividualDefaultTeamChanges() {
        const index = editingSingleDefaultTeam.originalIndex;
        const form = document.getElementById('edit-single-default-form');
        const teamToSave = sessionDefaultTeams[index];
        
        teamToSave.teamName = form.querySelector('[name="teamName"]').value.trim();
        teamToSave.startingPatientCount = parseInt(form.querySelector('[name="startingPatientCount"]').value, 10);
        teamToSave.preferredLocations = parseLocationsWithPriority(form.querySelector('[name="preferredLocationsText"]').value);
        teamToSave.otherLocations = form.querySelector('[name="otherLocationsText"]').value.split(',').map(s => s.trim()).filter(Boolean);
        teamToSave.avoidLocations = form.querySelector('[name="avoidLocationsText"]').value.split(',').map(s => s.trim()).filter(Boolean);
        teamToSave.prefersGynPatients = form.querySelector('[name="prefersGynPatients"]').checked;
        teamToSave.prefersSarcomaPatients = form.querySelector('[name="prefersSarcomaPatients"]').checked;
        teamToSave.lowCap = form.querySelector('[name="lowCap"]').checked;
        teamToSave.otherPreferences = form.querySelector('[name="otherPreferences"]').value.trim();

        editingSingleDefaultTeam = null;
        renderEditDefaultTeamsModal();
        displayGeneralModal(`Default for Team "${escapeHTML(teamToSave.teamName)}" updated for this session.`);
    }

    // --- RENDER FUNCTIONS --- //
    // These functions take the current state and build the HTML to display.
    
    function renderApp() {
        const appContainer = document.getElementById('app-container');
        appContainer.innerHTML = `
            <h1 class="text-4xl font-bold text-center text-blue-700 mb-6">Hospital Medicine AM Patient Assignment</h1>
            <p class="text-center text-xs text-gray-500 mb-6">Tip: Patient lists on teams are reset with each new assignment run (undo available for last run). Reset Teams clears current assignments without undo history.</p>

            <div class="bg-white p-6 rounded-xl shadow-md mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold text-blue-600">Current Teams (${teams.length})</h2>
                    <div class="space-x-2">
                        <button onclick="handleResetTeams()" class="btn-secondary" ${loading || teams.length === 0 ? 'disabled' : ''}>Reset Teams</button>
                        <button onclick="openMainEditAddModalNewTeam()" class="btn-primary">Edit/Add Teams</button>
                    </div>
                </div>
                <div id="teams-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    ${renderTeams()}
                </div>
            </div>

            <div class="bg-white p-6 rounded-xl shadow-md mb-8">
                <h2 class="text-2xl font-semibold text-blue-600 mb-4">Add New Unassigned Patient</h2>
                <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                    <div class="md:col-span-2"> <label for="patientName" class="label-text">Patient Name:</label> <input type="text" id="patientName" class="input-field" placeholder="e.g., John Doe" /> </div>
                    <div> <label for="patientLocation" class="label-text">Current Location:</label> <input type="text" id="patientLocation" class="input-field" placeholder="e.g., G21" /> </div>
                    <div> 
                        <label for="patientType" class="label-text">Patient Type:</label> 
                        <select id="patientType" class="input-field">
                            <option value="None">None</option> <option value="Gyn">Gyn</option> <option value="Sarcoma">Sarcoma</option>
                        </select>
                    </div>
                    <div class="flex items-center md:pt-6"> <input type="checkbox" id="needsHAndP" class="h-5 w-5 text-blue-600 border-gray-300 rounded focus:ring-blue-500 mr-2"/> <label for="needsHAndP" class="label-text mb-0">Needs H&P</label> </div>
                 </div>
                 <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mt-4">
                     <div class="md:col-span-2"> <label for="admittingTeam" class="label-text">Admitting Team (Optional):</label> <input type="text" id="admittingTeam" class="input-field" placeholder="e.g., ED Team" /> </div>
                     <div class="md:col-span-3 flex items-end"> <button onclick="addPatient()" class="w-full btn-primary">Add Patient to Unassigned List</button> </div>
                 </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                <div class="bg-white p-6 rounded-xl shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-2xl font-semibold text-blue-600">Unassigned Patients (${unassignedPatients.length})</h2>
                        <button onclick="deleteAllUnassignedPatients()" class="btn-secondary btn-small-action" ${loading || unassignedPatients.length === 0 ? 'disabled' : ''}>Del All</button>
                    </div>
                    <ul id="unassigned-patients-list" class="space-y-3 max-h-96 overflow-y-auto">${renderUnassignedPatients()}</ul>
                </div>
                <div class="bg-white p-6 rounded-xl shadow-md text-center flex flex-col justify-center space-y-4">
                    <button id="assign-btn" onclick="assignPatients()" class="w-full btn-primary text-xl py-3" ${loading || teams.length === 0 || unassignedPatients.length === 0 ? 'disabled' : ''}>
                        Assign Unassigned Patients
                    </button>
                    <button id="undo-btn" onclick="handleUndoAssignment()" class="w-full btn-neutral text-lg py-2" ${loading || !assignmentPerformedInSession ? 'disabled' : ''}>
                        Undo Most Recent Assignment
                    </button>
                    <div id="loading-spinner" style="display: none;" class="mt-2 text-blue-600 flex items-center justify-center">
                        <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg>
                        Processing...
                    </div>
                </div>
            </div>
            <div id="reports-container">
                ${renderReports()}
            </div>
        `;
    }

    function renderTeams() {
        if (teams.length === 0) return `<p class="text-gray-500 col-span-full">No teams loaded. Add teams or load defaults via 'Edit/Add Teams'.</p>`;
        
        return teams.map(team => `
            <div class="border border-gray-200 rounded-md p-3 bg-blue-50">
                <div class="flex justify-between items-start">
                    <h3 class="text-lg font-bold text-blue-800">${escapeHTML(team.teamName)}</h3>
                    <label class="checkbox-label bg-yellow-100 px-2 py-1 rounded ml-2">
                        <input type="checkbox" ${team.lowCap ? 'checked' : ''} onchange="handleLowCapChange('${team.id}', this.checked)" /> Low Cap (11)
                    </label>
                </div>
                <div class="text-sm text-gray-700 my-1 flex items-center">
                    <label class="font-semibold mr-2">Starting Patients:</label>
                    <input type="number" value="${team.startingPatientCount}" onblur="handleStartingPatientCountChange('${team.id}', this.value)" class="compact-input" min="0"/>
                </div>
                <p class="text-xs text-gray-600"><span class="font-semibold">Pref. Locations:</span> ${escapeHTML(formatLocationsWithPriority(team.preferredLocations)) || 'None'}</p>
                <div class="text-xs text-gray-600 flex items-center">
                    <span class="font-semibold mr-1">Other Locations:</span>
                    <input type="text" value="${escapeHTML((team.otherLocations || []).join(', '))}" onblur="handleOtherLocationsChange('${team.id}', this.value)"
                        class="ml-1 p-0.5 border border-gray-300 rounded text-xs flex-grow min-w-0" placeholder="e.g., ED, Clinic" />
                </div>
                <p class="text-xs text-gray-600"><span class="font-semibold">Avoid Locations:</span> ${escapeHTML((team.avoidLocations || []).join(', ')) || 'None'}</p>
                <p class="text-xs text-gray-600"><span class="font-semibold">Gyn Preference:</span> ${team.prefersGynPatients ? 'Yes' : 'No'}</p>
                <p class="text-xs text-gray-600"><span class="font-semibold">Sarcoma Preference:</span> ${team.prefersSarcomaPatients ? 'Yes' : 'No'}</p>
                ${team.otherPreferences ? `<p class="text-xs text-gray-600 mt-1 pt-1 border-t border-gray-300"><span class="font-semibold">Other Notes:</span> ${escapeHTML(team.otherPreferences)}</p>` : ''}
                <p class="text-sm text-gray-700 mt-2 pt-1 border-t border-gray-300 font-semibold">Assigned (this session):</p>
                <p class="text-sm text-gray-600">${renderTeamPatientSummary(team)}</p>
            </div>
        `).join('');
    }

    function renderTeamPatientSummary(team) {
        const patientsToDisplay = team.currentPatients || [];
        if (patientsToDisplay.length === 0) return "None";
        const needsHAndPCount = patientsToDisplay.filter(p => p.needsHAndP).length;
        const followUpCount = patientsToDisplay.length - needsHAndPCount;
        const pointsAdded = patientsToDisplay.reduce((sum, p) => sum + (p.needsHAndP ? 2 : 1), 0);
        let summary = `${patientsToDisplay.length} total (${pointsAdded} pts): `;
        if (followUpCount > 0) summary += `${followUpCount} follow-up(s)`;
        if (needsHAndPCount > 0) {
            if (followUpCount > 0) summary += ", ";
            summary += `${needsHAndPCount} H&P(s)`;
        }
        return escapeHTML(summary);
    }

    function renderUnassignedPatients() {
        if (unassignedPatients.length === 0) return `<p class="text-gray-500">No unassigned patients.</p>`;
        return unassignedPatients.map(p => `
            <li class="flex justify-between items-center border-b border-gray-200 pb-2 last:border-b-0">
                <div>
                    <p class="font-medium text-gray-800">${escapeHTML(p.patientName)}</p>
                    <p class="text-sm text-gray-600">Loc: ${escapeHTML(p.currentLocation)} ${p.patientType ? `(Type: ${escapeHTML(p.patientType)})` : ''} ${p.needsHAndP ? `<span class="font-semibold text-red-600">(Needs H&P)</span>` : ''}</p>
                    ${p.admittingTeam ? `<p class="text-xs text-gray-500">Admitting: ${escapeHTML(p.admittingTeam)}</p>` : ''}
                </div>
                <button onclick="deleteUnassignedPatient('${p.id}')" class="btn-secondary btn-small-action">Del</button>
            </li>
        `).join('');
    }

    function renderReports() {
        let html = '';
        if (assignmentReportData.length > 0) {
             html += `<div class="bg-green-50 p-6 rounded-xl shadow-md border border-green-200 mb-8"> 
                 <h2 class="text-2xl font-semibold text-green-700 mb-4">Assignment Report by Admitting Team</h2> 
                 <div class="max-h-96 overflow-y-auto text-sm"> 
                     ${assignmentReportData.reduce((acc, entry, index) => { 
                         const prevEntry = assignmentReportData[index - 1]; 
                         if (!prevEntry || prevEntry.admittingTeam !== entry.admittingTeam) { 
                             acc += `<h3 class="text-lg font-semibold text-green-600 mt-3 mb-1 pt-2 border-t border-green-200 first:mt-0 first:border-t-0"> Admitting Team: ${escapeHTML(entry.admittingTeam)} </h3>`; 
                         } 
                         acc += `<p class="ml-4 text-gray-700"> <span class="font-medium">${escapeHTML(entry.patientName)}</span> assigned to <span class="font-medium">${escapeHTML(entry.assignedTeamName)}</span> <span class="text-xs text-gray-500">(${escapeHTML(entry.phase)})</span> </p>`; 
                         return acc; 
                     }, '')} 
                 </div> 
             </div>`;
        }
        if (teamAssignmentSummaryData.length > 0) {
            html += `<div class="bg-indigo-50 p-6 rounded-xl shadow-md border border-indigo-200 mb-8"> 
                 <h2 class="text-2xl font-semibold text-indigo-700 mb-4">Team Assignment Summary</h2> 
                 <div class="max-h-96 overflow-y-auto text-sm"> 
                     ${teamAssignmentSummaryData.map(summary => `
                         <p class="text-gray-700 mb-1"> 
                             <span class="font-bold text-indigo-800">${escapeHTML(summary.teamName)}:</span> ${escapeHTML(String(summary.startingAmount))} + ${escapeHTML(String(summary.newlyAssignedCount))} = ${escapeHTML(String(summary.totalPatients))}${escapeHTML(summary.detailString)}
                         </p> 
                     `).join('')}
                 </div> 
             </div>`;
        }
        return html;
    }
    
    function renderMainModalTeamsList() {
        const container = document.getElementById('main-modal-teams-list');
        if (teams.length === 0) {
            container.innerHTML = `<p class="text-gray-500">No teams yet. Add one or load defaults.</p>`;
            return;
        }
        container.innerHTML = teams.map(t => `
            <li class="flex justify-between items-center p-2 border rounded-md hover:bg-gray-50">
                <span>${escapeHTML(t.teamName)} (Starts: ${t.startingPatientCount}) ${t.lowCap ? `<span class="text-xs bg-yellow-200 text-yellow-800 px-1 py-0.5 rounded-sm ml-1">LowCap</span>` : ''}</span>
                <div>
                    <button onclick="openMainEditAddModalExistingTeam('${t.id}')" class="text-blue-500 hover:text-blue-700 mr-2 text-sm">Edit</button>
                    <button onclick="confirmDeleteTeamForList('${t.id}')" class="text-red-500 hover:text-red-700 text-sm">Delete</button>
                </div>
            </li>
        `).join('');
    }

    function confirmDeleteTeamForList(teamId) {
        const team = teams.find(t => t.id === teamId);
        if(!team) return;
        editingTeamInMainModal = team; // set context for deletion
        confirmDeleteTeamFromMainModal();
    }

    function renderEditDefaultTeamsModal() {
        const container = document.getElementById('edit-default-teams-content');
        let content = `
            <h2 class="text-2xl font-semibold mb-6">Edit Session Default Team Set</h2>
            <p class="text-sm text-gray-600 mb-4">Changes made here apply to the "Load Default Team Set" button for this session only.</p>
        `;

        if (editingSingleDefaultTeam) {
            const team = editingSingleDefaultTeam;
            content += `
            <form id="edit-single-default-form" class="border p-4 rounded-md bg-gray-50 mb-4">
                <h3 class="text-lg font-semibold mb-2">Editing: ${escapeHTML(team.teamName)}</h3>
                <div class="space-y-2 text-left">
                    <div><label class="label-text">Team Name:</label><input type="text" name="teamName" value="${escapeHTML(team.teamName)}" class="input-field"/></div>
                    <div><label class="label-text">Starting Count:</label><input type="number" name="startingPatientCount" value="${team.startingPatientCount}" class="input-field"/></div>
                    <div><label class="label-text">Preferred Locations:</label><input type="text" name="preferredLocationsText" value="${escapeHTML(formatLocationsWithPriority(team.preferredLocations))}" class="input-field"/></div>
                    <div><label class="label-text">Other Locations:</label><input type="text" name="otherLocationsText" value="${escapeHTML((team.otherLocations || []).join(', '))}" class="input-field"/></div>
                    <div><label class="label-text">Avoid Locations:</label><input type="text" name="avoidLocationsText" value="${escapeHTML((team.avoidLocations || []).join(', '))}" class="input-field"/></div>
                    <div class="flex items-center space-x-6"><input type="checkbox" name="prefersGynPatients" ${team.prefersGynPatients ? 'checked' : ''} class="mr-2"/><label class="label-text mb-0">Prefers Gyn</label></div>
                    <div class="flex items-center space-x-6"><input type="checkbox" name="prefersSarcomaPatients" ${team.prefersSarcomaPatients ? 'checked' : ''} class="mr-2"/><label class="label-text mb-0">Prefers Sarcoma</label></div>
                    <div class="flex items-center"><input type="checkbox" name="lowCap" ${team.lowCap ? 'checked' : ''} class="mr-2"/><label class="label-text mb-0">Low Cap</label></div>
                    <div><label class="label-text">Other Preferences:</label><textarea name="otherPreferences" class="input-field" rows="2">${escapeHTML(team.otherPreferences || '')}</textarea></div>
                </div>
                <div class="mt-4 flex justify-end space-x-2">
                    <button type="button" onclick="editingSingleDefaultTeam=null; renderEditDefaultTeamsModal();" class="btn-neutral">Cancel Edit</button>
                    <button type="button" onclick="saveIndividualDefaultTeamChanges()" class="btn-primary">Save This Default</button>
                </div>
            </form>
            `;
        } else {
            content += `<div class="max-h-96 overflow-y-auto space-y-2 mb-4">
                ${sessionDefaultTeams.map((team, index) => `
                    <div class="p-3 border rounded-md flex justify-between items-center hover:bg-gray-50">
                        <div>
                            <p class="font-semibold">${escapeHTML(team.teamName)} <span class="text-xs text-gray-500">(Starts: ${team.startingPatientCount})</span></p>
                            <p class="text-xs">Prefs: ${escapeHTML(formatLocationsWithPriority(team.preferredLocations)) || 'None'}</p>
                        </div>
                        <button onclick="startEditSingleDefaultTeam(${index})" class="btn-neutral btn-small-action">Edit</button>
                    </div>
                `).join('')}
            </div>`;
        }

        content += `<button onclick="closeEditDefaultTeamsModal()" class="btn-primary">Done Editing Defaults</button>`;
        container.innerHTML = content;
    }

    function handleLowCapChange(teamId, isChecked) {
        const team = teams.find(t => t.id === teamId);
        if (team) team.lowCap = isChecked;
        // No need to re-render the whole app, just this checkbox state is fine.
        // If other logic depended on this, we would call renderApp().
    }

    function handleStartingPatientCountChange(teamId, newCountStr) {
        const newCount = parseInt(newCountStr, 10);
        if (isNaN(newCount) || newCount < 0) return;
        const team = teams.find(t => t.id === teamId);
        if (team) team.startingPatientCount = newCount;
    }

    function handleOtherLocationsChange(teamId, newLocationsText) {
        const otherLocationsArray = newLocationsText.split(',').map(loc => loc.trim()).filter(Boolean);
        const team = teams.find(t => t.id === teamId);
        if (team) team.otherLocations = otherLocationsArray;
    }

    function setLoadingState(isLoading) {
        loading = isLoading;
        document.getElementById('loading-spinner').style.display = isLoading ? 'flex' : 'none';
        document.getElementById('assign-btn').disabled = isLoading || teams.length === 0 || unassignedPatients.length === 0;
        document.getElementById('undo-btn').disabled = isLoading || !assignmentPerformedInSession;
    }


    // --- INITIALIZATION --- //
    window.onload = () => {
        // Load default teams on startup
        _loadDefaultTeamsData();
        
        // Initial render of the entire application
        renderApp();
        renderMainModalTeamsList();
    };

    </script>
</body>
</html>