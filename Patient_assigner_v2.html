<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Assignment App</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .btn-primary { background-color: #2563eb; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; transition: 0.15s; font-weight: 600; cursor: pointer; } 
        .btn-primary:hover { background-color: #1d4ed8; } 
        .btn-primary:disabled { background-color: #9ca3af; cursor: not-allowed; }
        
        .btn-secondary { background-color: #dc2626; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; transition: 0.15s; font-weight: 600; cursor: pointer; } 
        .btn-secondary:hover { background-color: #b91c1c; }
        .btn-secondary:disabled { background-color: #f87171; cursor: not-allowed; }
        
        .btn-neutral { background-color: #6b7280; color: white; padding: 0.5rem 1rem; border-radius: 0.5rem; transition: 0.15s; font-weight: 600; cursor: pointer; } 
        .btn-neutral:hover { background-color: #4b5563; }
        
        .input-field { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; }
        .compact-input { width: 4rem; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; }
        
        .modal-backdrop { position: fixed; inset: 0; background-color: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 50; padding: 1rem; }
        .modal-content { background-color: white; padding: 2rem; border-radius: 0.75rem; width: 100%; max-width: 32rem; max-height: 90vh; overflow-y: auto; text-align: center; }
        .modal-content-large { max-width: 42rem; }
        
        .textarea-large { width: 100%; min-height: 200px; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-family: monospace; font-size: 0.875rem; }
        
        .label-text { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; font-weight: 500; color: #374151; }
        .checkbox-label { display: flex; align-items: center; font-size: 0.875rem; color: #374151; } 
        .checkbox-label input { margin-right: 0.5rem; height: 1rem; width: 1rem; }
        
        /* Utility for small action buttons */
        .btn-small-action { padding: 0.25rem 0.5rem; font-size: 0.75rem; }
    </style>
</head>
<body class="bg-gray-100 font-sans text-gray-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Polyfill for crypto.randomUUID if not available (e.g. non-secure context)
        const generateUUID = () => {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };

        // ==========================================
        // SECTION 1: CONSTANTS & INITIAL DATA
        // ==========================================

        const initialTeamFormState = {
            id: null, teamName: '', startingPatientCount: 0, preferredLocationsText: '',
            otherLocationsText: '', avoidLocationsText: '', prefersGynPatients: false,
            prefersSarcomaPatients: false, otherPreferences: '', lowCap: false,
        };

        const defaultTeamDataArray = [
            { teamName: 'A', preferredLocations: [{ location: 'P4', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'B', preferredLocations: [{ location: 'G21', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'C', preferredLocations: [{ location: 'G22', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'E', avoidLocations: ['G22', 'G21', 'G11', 'P4'], otherPreferences: 'Tries to avoid G22, G21, G11, P4.', startingPatientCount: 0, preferredLocations: [], otherLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false }, 
            { teamName: 'F', preferredLocations: [{ location: 'G22', priority: 2 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'G', preferredLocations: [{ location: 'G21', priority: 2 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'H', preferredLocations: [], avoidLocations: ['G22', 'G21', 'G11', 'G7'], otherPreferences: '', startingPatientCount: 0, otherLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false }, 
            { teamName: 'I', preferredLocations: [{ location: 'G7', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'J', preferredLocations: [{ location: 'G11', priority: 1 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'K', preferredLocations: [], avoidLocations: ['G22', 'G21', 'G11', 'G7'], otherPreferences: '', startingPatientCount: 0, otherLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'L', preferredLocations: [{ location: 'G11', priority: 2 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'N', prefersGynPatients: true, otherPreferences: 'Preferred team for Gyn patients.', startingPatientCount: 0, preferredLocations: [], otherLocations: [], avoidLocations: [], prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
            { teamName: 'O', preferredLocations: [{ location: 'G21', priority: 3 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: true, currentPatients: [], lowCap: false },
            { teamName: 'P', preferredLocations: [{ location: 'G22', priority: 3 }], otherPreferences: '', startingPatientCount: 0, otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: false },
        ];

        const supportTeamOrder = ['Team M', 'Backup 1', 'Backup 2', 'Backup 3', 'Moonlighter 1', 'Moonlighter 2', 'Moonlighter 3'];

        // ==========================================
        // SECTION 2: UTILITY & ALGORITHM FUNCTIONS
        // ==========================================

        const parseLocationsWithPriority = (text) => {
            if (!text || text.trim() === '') return [];
            return text.split(',').map(part => {
                part = part.trim();
                const match = part.match(/(.+)\s\((\d+)\)$/);
                return match ? { location: match[1].trim(), priority: parseInt(match[2], 10) } : { location: part, priority: 1 };
            }).filter(loc => loc.location !== '');
        };

        const formatLocationsWithPriority = (locationsArray) => {
            return (locationsArray || []).map(loc => loc.priority === 1 ? loc.location : `${loc.location} (${loc.priority})`).join(', ');
        };

        const getSwapPatientScore = (patient, team) => {
            let score = 0;
            const isGyn = patient.type?.toLowerCase() === 'gyn';
            const isSarcoma = patient.type?.toLowerCase() === 'sarcoma';

            if (isGyn) {
                if (team.prefersGynPatients) score += 20000; 
                else score -= 5000; 
            } else { 
                if (team.prefersGynPatients) score -= 500; 
            }

            if (isSarcoma) {
                if (team.prefersSarcomaPatients) score += 20000;
                else score -= 5000;
            } else {
                if (team.prefersSarcomaPatients) score -= 500;
            }

            const p1Match = team.preferredLocations.find(pl => pl.location === patient.location && pl.priority === 1);
            const p2Match = team.preferredLocations.find(pl => pl.location === patient.location && pl.priority === 2);
            const p3Match = team.preferredLocations.find(pl => pl.location === patient.location && pl.priority === 3);

            if (p1Match) score += 10000;
            else if (p2Match) score += 4000;
            else if (p3Match) score += 2000;
            else if (team.otherLocations.includes(patient.location)) score += 1000;
            
            return score;
        };

        const findBestTeamForPatient = (patient, availableTeams, rules, allTeamsForLoadBalancing) => {
            let bestTeam = null;
            let highestScore = -Infinity;

            for (const team of availableTeams) {
                const teamCap = team.cap || (team.lowCap ? 10 : 16);
                const currentPatientSlotsFilled = team.startingPatientCount + team.currentPatientsThisSession.length;
                if (currentPatientSlotsFilled >= teamCap && !(teamCap === 16 && currentPatientSlotsFilled === 15 && patient.needsHAndP)) {
                    continue;
                }

                let score = 0;
                if (rules.phase === 'sarcoma' && patient.patientType?.toLowerCase() === 'sarcoma' && team.prefersSarcomaPatients) score += 1000;
                if (rules.phase === 'gyn' && patient.patientType?.toLowerCase() === 'gyn' && team.prefersGynPatients) score += 1000;
                
                if (rules.phase === 'prefLoc') {
                    const preferredMatch = team.preferredLocations.find(pl => pl.location === patient.currentLocation);
                    if (preferredMatch) score += 500 + (5 - preferredMatch.priority);
                    else continue; 
                }

                if (team.avoidLocations.includes(patient.currentLocation)) score -= rules.relaxAvoid ? 50 : 1000;
                
                if (rules.phase !== 'sarcoma' && patient.patientType?.toLowerCase() === 'sarcoma' && team.prefersSarcomaPatients) score += 100;
                if (rules.phase !== 'gyn' && patient.patientType?.toLowerCase() === 'gyn' && team.prefersGynPatients) score += 100;

                if (rules.phase !== 'prefLoc') {
                    const preferredMatch = team.preferredLocations.find(pl => pl.location === patient.currentLocation);
                    if (preferredMatch) score += 50 + (5 - preferredMatch.priority);
                    else if (team.otherLocations.includes(patient.currentLocation)) score += 35; 
                }
                if (team.currentPatientsThisSession.some(p => p.location === patient.currentLocation)) score += 15; 

                if (patient.needsHAndP) {
                    if (team.needsHAndPThisSessionCount > 0) { score -= 200; score -= team.newPatientsThisSessionCount * 10; }
                    if (team.cap - currentPatientSlotsFilled === 1) score += 150; 
                }

                let potentialNextTotalSlotsList = allTeamsForLoadBalancing.map(tCopy => (tCopy.startingPatientCount || 0) + tCopy.currentPatientsThisSession.length + (tCopy.id === team.id ? 1 : 0));
                const minPotentialTotalSlots = Math.min(...potentialNextTotalSlotsList);
                const maxPotentialTotalSlots = Math.max(...potentialNextTotalSlotsList);
                const diffInTotalSlots = maxPotentialTotalSlots - minPotentialTotalSlots;

                if (diffInTotalSlots === 0) score += 400; 
                else if (diffInTotalSlots === 1) score += 300; 
                else if (diffInTotalSlots === 2) score += 150; 
                else score -= diffInTotalSlots * 100;

                const pointsFromThisPatient = patient.needsHAndP ? 2 : 1;
                let potentialNextAddedPointsList = allTeamsForLoadBalancing.map(tCopy => tCopy.currentLoad + (tCopy.id === team.id ? pointsFromThisPatient : 0));
                const minPotentialAddedPoints = Math.min(...potentialNextAddedPointsList);
                const maxPotentialAddedPoints = Math.max(...potentialNextAddedPointsList);
                const diffInAddedPoints = maxPotentialAddedPoints - minPotentialAddedPoints;

                if (diffInAddedPoints <= 1) score += 150; 
                else if (diffInAddedPoints === 2) score += 75; 
                else score -= diffInAddedPoints * 10; 
                
                score -= team.currentLoad * 0.25; 

                if (score > highestScore) {
                    highestScore = score;
                    bestTeam = team;
                } else if (score === highestScore) { 
                    if (!bestTeam) bestTeam = team;
                    else {
                        if (team.startingPatientCount < bestTeam.startingPatientCount) bestTeam = team;
                        else if (team.startingPatientCount === bestTeam.startingPatientCount && team.currentLoad < bestTeam.currentLoad) bestTeam = team;
                    }
                }
            }
            return { bestTeam, highestScore };
        };

        const swapPhaseLogic = (teamsInput, maxSwapIterations = 3, minBenefitThreshold = 100) => {
            let teams = JSON.parse(JSON.stringify(teamsInput));
            let overallSwapMadeThisRun = false;
            
            // --- H&P Upgrade Swap Sub-Phase ---
            for (let upgradeIter = 0; upgradeIter < 5; upgradeIter++) {
                let upgradeSwapMade = false;
                let bestUpgradeSwap = null;
                const singleFollowUpTeams = teams.filter(t => !supportTeamOrder.includes(t.teamName) && t.currentPatientsThisSession.length === 1 && !t.currentPatientsThisSession[0].needsHAndP);
                const potentialHnpDonorTeams = teams.filter(t => !supportTeamOrder.includes(t.teamName) && t.currentPatientsThisSession.length > 1 && t.currentPatientsThisSession.some(p => p.needsHAndP));

                if (singleFollowUpTeams.length === 0 || potentialHnpDonorTeams.length === 0) break;

                for (const targetTeam of singleFollowUpTeams) {
                    const followUpPatient = targetTeam.currentPatientsThisSession[0];
                    for (const donorTeam of potentialHnpDonorTeams) {
                        if (targetTeam.id === donorTeam.id) continue;
                        for (let hnpIdx = 0; hnpIdx < donorTeam.currentPatientsThisSession.length; hnpIdx++) {
                            const hnpPatient = donorTeam.currentPatientsThisSession[hnpIdx];
                            if (!hnpPatient.needsHAndP) continue;
                            if (donorTeam.avoidLocations.includes(followUpPatient.location) || targetTeam.avoidLocations.includes(hnpPatient.location)) continue;
                            if (hnpPatient.type?.toLowerCase() === 'gyn' && donorTeam.prefersGynPatients && !targetTeam.prefersGynPatients) continue;
                            if (hnpPatient.type?.toLowerCase() === 'sarcoma' && donorTeam.prefersSarcomaPatients && !targetTeam.prefersSarcomaPatients) continue;
                            
                            bestUpgradeSwap = { targetTeamId: targetTeam.id, donorTeamId: donorTeam.id, hnpPatientIndex: hnpIdx };
                            break; 
                        }
                        if (bestUpgradeSwap) break; 
                    }
                    if (bestUpgradeSwap) break;
                }

                if (bestUpgradeSwap) {
                    const targetTeam = teams.find(t => t.id === bestUpgradeSwap.targetTeamId);
                    const donorTeam = teams.find(t => t.id === bestUpgradeSwap.donorTeamId);
                    const followUpData = targetTeam.currentPatientsThisSession[0];
                    const hnpData = donorTeam.currentPatientsThisSession[bestUpgradeSwap.hnpPatientIndex];
                    targetTeam.currentPatientsThisSession[0] = hnpData;
                    donorTeam.currentPatientsThisSession[bestUpgradeSwap.hnpPatientIndex] = followUpData;
                    targetTeam.needsHAndPThisSessionCount = 1;
                    donorTeam.needsHAndPThisSessionCount = donorTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                    upgradeSwapMade = true;
                    overallSwapMadeThisRun = true;
                }
                if (!upgradeSwapMade) break;
            }

            // --- H&P Downgrade Swap Sub-Phase ---
            for (let downgradeIter = 0; downgradeIter < 5; downgradeIter++) {
                let downgradeSwapMade = false;
                let bestDowngradeSwap = null;
                const potentialDowngradeTeams = teams.filter(t => !supportTeamOrder.includes(t.teamName) && t.currentPatientsThisSession.length >= 2 && t.currentPatientsThisSession.some(p => p.needsHAndP));
                const potentialUpgradeTeams = teams.filter(t => !supportTeamOrder.includes(t.teamName) && t.currentPatientsThisSession.length === 1 && !t.currentPatientsThisSession[0].needsHAndP);

                if (potentialDowngradeTeams.length === 0 || potentialUpgradeTeams.length === 0) break;
                
                for (const downgradingTeam of potentialDowngradeTeams) {
                    for (const upgradingTeam of potentialUpgradeTeams) {
                        if (downgradingTeam.id === upgradingTeam.id) continue;
                        const followUpPatient = upgradingTeam.currentPatientsThisSession[0];
                        for (let hnpIdx = 0; hnpIdx < downgradingTeam.currentPatientsThisSession.length; hnpIdx++) {
                            const hnpPatient = downgradingTeam.currentPatientsThisSession[hnpIdx];
                            if (!hnpPatient.needsHAndP) continue;
                            bestDowngradeSwap = { downgradingTeamId: downgradingTeam.id, upgradingTeamId: upgradingTeam.id, hnpPatientIndex: hnpIdx };
                            break; 
                        }
                        if (bestDowngradeSwap) break; 
                    }
                    if (bestDowngradeSwap) break;
                }

                if (bestDowngradeSwap) {
                    const downgradingTeam = teams.find(t => t.id === bestDowngradeSwap.downgradingTeamId);
                    const upgradingTeam = teams.find(t => t.id === bestDowngradeSwap.upgradingTeamId);
                    const hnpData = downgradingTeam.currentPatientsThisSession[bestDowngradeSwap.hnpPatientIndex];
                    const followUpData = upgradingTeam.currentPatientsThisSession[0];
                    downgradingTeam.currentPatientsThisSession[bestDowngradeSwap.hnpPatientIndex] = followUpData;
                    upgradingTeam.currentPatientsThisSession[0] = hnpData;
                    downgradingTeam.needsHAndPThisSessionCount = downgradingTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                    upgradingTeam.needsHAndPThisSessionCount = upgradingTeam.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                    downgradeSwapMade = true;
                    overallSwapMadeThisRun = true;
                }
                if (!downgradeSwapMade) break;
            }

            // --- General Preference Swap Phase ---
            for (let iter = 0; iter < maxSwapIterations; iter++) {
                let swapMadeInThisIteration = false;
                let bestSwapCandidate = null; 

                for (let i = 0; i < teams.length; i++) { 
                    for (let j = i + 1; j < teams.length; j++) { 
                        const teamA = teams[i];
                        const teamB = teams[j];
                        if (supportTeamOrder.includes(teamA.teamName) || supportTeamOrder.includes(teamB.teamName)) continue;

                        for (let p1Idx = 0; p1Idx < teamA.currentPatientsThisSession.length; p1Idx++) {
                            const patient1 = teamA.currentPatientsThisSession[p1Idx];
                            for (let p2Idx = 0; p2Idx < teamB.currentPatientsThisSession.length; p2Idx++) {
                                const patient2 = teamB.currentPatientsThisSession[p2Idx];

                                if (patient1.needsHAndP !== patient2.needsHAndP) continue;
                                if (teamB.avoidLocations.includes(patient1.location) || teamA.avoidLocations.includes(patient2.location)) continue;

                                const currentScoreP1 = getSwapPatientScore(patient1, teamA);
                                const currentScoreP2 = getSwapPatientScore(patient2, teamB);
                                const potentialScoreP1onB = getSwapPatientScore(patient1, teamB);
                                const potentialScoreP2onA = getSwapPatientScore(patient2, teamA);
                                const netBenefit = (potentialScoreP1onB + potentialScoreP2onA) - (currentScoreP1 + currentScoreP2);

                                if (netBenefit > (bestSwapCandidate ? bestSwapCandidate.benefit : minBenefitThreshold -1) ) {
                                    bestSwapCandidate = { teamAIdx: i, p1Idx: p1Idx, teamBIdx: j, p2Idx: p2Idx, benefit: netBenefit };
                                }
                            }
                        }
                    }
                }

                if (bestSwapCandidate) {
                    const { teamAIdx, p1Idx, teamBIdx, p2Idx } = bestSwapCandidate;
                    const patient1Data = teams[teamAIdx].currentPatientsThisSession[p1Idx];
                    const patient2Data = teams[teamBIdx].currentPatientsThisSession[p2Idx];
                    teams[teamAIdx].currentPatientsThisSession[p1Idx] = patient2Data;
                    teams[teamBIdx].currentPatientsThisSession[p2Idx] = patient1Data;
                    teams[teamAIdx].needsHAndPThisSessionCount = teams[teamAIdx].currentPatientsThisSession.filter(p => p.needsHAndP).length;
                    teams[teamBIdx].needsHAndPThisSessionCount = teams[teamBIdx].currentPatientsThisSession.filter(p => p.needsHAndP).length;
                    swapMadeInThisIteration = true;
                    overallSwapMadeThisRun = true;
                    iter = -1; 
                }
                if (!swapMadeInThisIteration && iter > -1) break; 
            }
            return teams;
        };

        const fillUnderutilizedTeamsPhase = (teamsInput, capUtilizationThreshold = 0.6, maxHAndPProportion = 0.4, maxFillIterations = 5) => {
            let teams = JSON.parse(JSON.stringify(teamsInput));
            for (let fillIter = 0; fillIter < maxFillIterations; fillIter++) {
                let moveMadeThisPass = false;
                teams.forEach(team => { team.totalSlots = (team.startingPatientCount || 0) + team.currentPatientsThisSession.length; });
                const underutilizedTeams = teams.filter(t => t.totalSlots < t.cap && (t.totalSlots / t.cap) < capUtilizationThreshold).sort((a, b) => (a.totalSlots / a.cap) - (b.totalSlots / b.cap)); 
                const potentialDonorTeams = teams.filter(t => !supportTeamOrder.includes(t.teamName) && !underutilizedTeams.find(ut => ut.id === t.id) && t.currentPatientsThisSession.length > 0).sort((a, b) => b.totalSlots - a.totalSlots); 

                if (underutilizedTeams.length === 0 || potentialDonorTeams.length === 0) break; 

                for (const targetTeam of underutilizedTeams) {
                    if (targetTeam.totalSlots >= targetTeam.cap) continue;
                    let bestPatientToMoveFromAnyDonor = null; 

                    for (const donorTeam of potentialDonorTeams) {
                        if (donorTeam.id === targetTeam.id || donorTeam.currentPatientsThisSession.length === 0) continue;
                        const avgSlots = teams.reduce((sum, t) => sum + t.totalSlots, 0) / teams.length;
                        if (donorTeam.totalSlots <= targetTeam.totalSlots + 1 && !(donorTeam.totalSlots > avgSlots && targetTeam.totalSlots < avgSlots) ) continue;

                        for (let pIdx = 0; pIdx < donorTeam.currentPatientsThisSession.length; pIdx++) {
                            const patient = donorTeam.currentPatientsThisSession[pIdx];
                            let moveScore = 0; 
                            if (targetTeam.avoidLocations.includes(patient.location)) continue;
                            
                            const donorHasPref = donorTeam.preferredLocations.some(pl => pl.location === patient.location);
                            const targetHasPref = targetTeam.preferredLocations.some(pl => pl.location === patient.location);
                            if (donorHasPref && !targetHasPref) moveScore -= 2000;
                            else if (!donorHasPref && targetHasPref) moveScore += 1000;
                            
                            if (!bestPatientToMoveFromAnyDonor || moveScore > bestPatientToMoveFromAnyDonor.moveScore) {
                                bestPatientToMoveFromAnyDonor = { patient, indexInDonor: pIdx, donorTeam, targetTeam, moveScore };
                            }
                        }
                    }

                    if (bestPatientToMoveFromAnyDonor && bestPatientToMoveFromAnyDonor.moveScore > -1000) { 
                        const { patient, indexInDonor, donorTeam, targetTeam: recipientTeam } = bestPatientToMoveFromAnyDonor; 
                        donorTeam.currentPatientsThisSession.splice(indexInDonor, 1);
                        recipientTeam.currentPatientsThisSession.push(patient);
                        [donorTeam, recipientTeam].forEach(t => {
                            t.totalSlots = (t.startingPatientCount || 0) + t.currentPatientsThisSession.length;
                            t.needsHAndPThisSessionCount = t.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                            t.currentLoad = t.currentPatientsThisSession.reduce((sum, p) => sum + (p.needsHAndP ? 2 : 1), 0);
                        });
                        moveMadeThisPass = true;
                        break; 
                    }
                } 
                if (moveMadeThisPass) { fillIter = -1; continue; } 
                else break; 
            } 
            teams.forEach(team => delete team.totalSlots); 
            return teams;
        };

        const equalizeFinalCountsPhase = (teamsInput, maxIterations = 10) => {
            let teams = JSON.parse(JSON.stringify(teamsInput));
            for (let iter = 0; iter < maxIterations; iter++) {
                let moveMadeInIteration = false;
                teams.forEach(team => {
                    team.cap = team.lowCap ? 10 : 16;
                    team.currentTotalSlots = (team.startingPatientCount || 0) + team.currentPatientsThisSession.length;
                    team.slotsFromCap = team.cap - team.currentTotalSlots;
                    team.needsHAndPThisSessionCount = team.currentPatientsThisSession.filter(p => p.needsHAndP).length;
                });

                const nonLowCapTeams = teams.filter(t => !t.lowCap);
                if (nonLowCapTeams.length <= 1) break;

                const nonLowCapSlotsFromCap = nonLowCapTeams.map(t => t.slotsFromCap);
                const minSlotsFromCap = Math.min(...nonLowCapSlotsFromCap);
                const maxSlotsFromCap = Math.max(...nonLowCapSlotsFromCap);

                if (maxSlotsFromCap - minSlotsFromCap <= 1) break;

                const potentialDonors = nonLowCapTeams.filter(t => t.slotsFromCap === minSlotsFromCap && t.currentPatientsThisSession.length > 0).sort((a, b) => a.currentLoad - b.currentLoad);
                const potentialRecipients = teams.filter(t => t.currentTotalSlots < t.cap && ((!t.lowCap && t.slotsFromCap === maxSlotsFromCap) || (t.lowCap))).sort((a, b) => b.slotsFromCap - a.slotsFromCap);
                if (potentialDonors.length === 0 || potentialRecipients.length === 0) break;

                let bestMoveDetails = null;
                let highestMovePriority = -Infinity;

                donorLoop: for (const currentDonor of potentialDonors) {
                    recipientLoop: for (const currentRecipient of potentialRecipients) {
                        if (currentDonor.id === currentRecipient.id) continue;
                        for (let pIdx = 0; pIdx < currentDonor.currentPatientsThisSession.length; pIdx++) {
                            const patient = currentDonor.currentPatientsThisSession[pIdx];
                            let currentMovePriority = 50000;
                            if (patient.needsHAndP) {
                                if (currentRecipient.needsHAndPThisSessionCount >= 2) { currentMovePriority = -Infinity; break; }
                                else currentMovePriority += 2000;
                            }
                            if (currentMovePriority === -Infinity) continue;
                            
                            if (currentMovePriority > highestMovePriority) {
                                highestMovePriority = currentMovePriority;
                                bestMoveDetails = { patient, indexInDonor: pIdx, donorTeam: currentDonor, recipientTeam: currentRecipient };
                            }
                        }
                    }
                }

                if (bestMoveDetails && highestMovePriority > -Infinity) {
                    const { patient, indexInDonor, donorTeam: actualDonor, recipientTeam: actualRecipient } = bestMoveDetails;
                    actualDonor.currentPatientsThisSession.splice(indexInDonor, 1);
                    actualRecipient.currentPatientsThisSession.push(patient);
                    moveMadeInIteration = true;
                }
                if (!moveMadeInIteration) break;
            }
            teams.forEach(team => { delete team.currentTotalSlots; delete team.slotsFromCap; delete team.cap; });
            return teams;
        };

        const balanceNewPatientWorkloadPhase = (teamsInput, maxIterations = 5) => {
            let teams = JSON.parse(JSON.stringify(teamsInput));
            for (let iter = 0; iter < maxIterations; iter++) {
                let moveMadeInIteration = false;
                let bestMove = null;
                let highestBenefit = 0;

                teams.forEach(team => {
                    team.cap = team.lowCap ? 10 : 16;
                    team.currentTotalSlots = (team.startingPatientCount || 0) + team.currentPatientsThisSession.length;
                    team.newPatientCount = team.currentPatientsThisSession.length;
                });

                const nonLowCapTeams = teams.filter(t => !t.lowCap);

                for (const donor of teams.filter(t => !supportTeamOrder.includes(t.teamName))) {
                    for (const recipient of teams) {
                        if (donor.id === recipient.id || recipient.currentTotalSlots >= recipient.cap || donor.newPatientCount <= recipient.newPatientCount) continue;
                        
                        let isDonorNonLowCap = nonLowCapTeams.some(t => t.id === donor.id);
                        let isRecipientNonLowCap = nonLowCapTeams.some(t => t.id === recipient.id);
                        if (isDonorNonLowCap || isRecipientNonLowCap) {
                            let tempSlots = nonLowCapTeams.map(t => {
                                let slots = t.cap - ((t.startingPatientCount || 0) + t.currentPatientsThisSession.length);
                                if (t.id === donor.id) return slots + 1;
                                if (t.id === recipient.id) return slots - 1;
                                return slots;
                            });
                            if (Math.max(...tempSlots) - Math.min(...tempSlots) > 1) continue;
                        }

                        const patientsToConsider = donor.currentPatientsThisSession.filter(p => !p.needsHAndP);
                        for (const patient of patientsToConsider) {
                            let moveScore = 1000; 
                            if (recipient.avoidLocations.includes(patient.location)) continue;
                            const benefit = moveScore + (donor.newPatientCount - recipient.newPatientCount) * 100;
                            if (benefit > highestBenefit) {
                                highestBenefit = benefit;
                                bestMove = { patient, donor, recipient, patientIndex: donor.currentPatientsThisSession.findIndex(p => p.originalPatientId === patient.originalPatientId) };
                            }
                        }
                    }
                }

                if (bestMove) {
                    const { donor, recipient, patientIndex } = bestMove;
                    const donorInArray = teams.find(t => t.id === donor.id);
                    const recipientInArray = teams.find(t => t.id === recipient.id);
                    const [movedPatient] = donorInArray.currentPatientsThisSession.splice(patientIndex, 1);
                    recipientInArray.currentPatientsThisSession.push(movedPatient);
                    moveMadeInIteration = true;
                }
                if (!moveMadeInIteration) break;
            }
            teams.forEach(team => { delete team.cap; delete team.currentTotalSlots; delete team.newPatientCount; });
            return teams;
        }

        const assignPatientsLogic = (currentTeams, currentUnassignedPatients) => {
            let teamsCopy = JSON.parse(JSON.stringify(currentTeams)).map(team => ({
                ...team,
                cap: team.cap || (team.lowCap ? 10 : 16),
                currentPatientsThisSession: team.currentPatientsThisSession || [], 
                currentLoad: team.currentLoad || 0, 
                needsHAndPThisSessionCount: team.needsHAndPThisSessionCount || 0,
                newPatientsThisSessionCount: team.newPatientsThisSessionCount || 0, 
            }));

            let patientsToProcess = JSON.parse(JSON.stringify(currentUnassignedPatients));
            const newlyAssignedPatientsLog = [];
            let assignedPatientIdsThisRun = new Set(); 

            const assignPatientToTeam = (patient, team, score, phase) => {
                const teamToUpdate = teamsCopy.find(t => t.id === team.id);
                const patientDataForTeam = { 
                    name: patient.patientName, 
                    location: patient.currentLocation, 
                    type: patient.patientType || '', 
                    needsHAndP: patient.needsHAndP || false,
                    originalPatientId: patient.id 
                };
                teamToUpdate.currentPatientsThisSession.push(patientDataForTeam);
                teamToUpdate.newPatientsThisSessionCount += 1;
                teamToUpdate.currentLoad += (patient.needsHAndP ? 2 : 1); 
                if (patient.needsHAndP) teamToUpdate.needsHAndPThisSessionCount += 1;
                newlyAssignedPatientsLog.push({ ...patient, assignedTeamName: team.teamName, assignmentScore: score, phase });
                assignedPatientIdsThisRun.add(patient.id);
            };

            const runAssignmentPhase = (filterFn, sortFn, findTeamOptions) => {
                let phasePatients = patientsToProcess.filter(p => !assignedPatientIdsThisRun.has(p.id) && filterFn(p));
                if(sortFn) phasePatients.sort(sortFn);
                for (const patient of phasePatients) {
                    if (assignedPatientIdsThisRun.has(patient.id)) continue;
                    const teamsToTry = findTeamOptions.getTeams(teamsCopy, patient);
                    if (teamsToTry.length > 0) {
                        const result = findBestTeamForPatient(patient, teamsToTry, findTeamOptions.rules, teamsCopy);
                        if (result.bestTeam) assignPatientToTeam(patient, result.bestTeam, result.highestScore, findTeamOptions.phaseName);
                    }
                }
            };

            runAssignmentPhase(p => p.patientType?.toLowerCase() === 'sarcoma', (a,b) => a.patientName.localeCompare(b.patientName), {
                getTeams: (teams) => teams.filter(t => t.prefersSarcomaPatients),
                rules: { phase: 'sarcoma', relaxAvoid: false },
                phaseName: 'Sarcoma-Preferred'
            });

            runAssignmentPhase(p => p.patientType?.toLowerCase() === 'gyn', (a,b) => a.patientName.localeCompare(b.patientName), {
                getTeams: (teams) => teams.filter(t => t.prefersGynPatients),
                rules: { phase: 'gyn', relaxAvoid: false },
                phaseName: 'Gyn-Preferred'
            });

            runAssignmentPhase(() => true, (a,b) => a.patientName.localeCompare(b.patientName), {
                getTeams: (teams, p) => teams.filter(team => team.preferredLocations.some(pl => pl.location === p.currentLocation)),
                rules: { phase: 'prefLoc', relaxAvoid: false },
                phaseName: 'Preferred-Location'
            });

            let iterationNeeded = true;
            while(iterationNeeded && patientsToProcess.some(p => !assignedPatientIdsThisRun.has(p.id))) {
                iterationNeeded = false;
                runAssignmentPhase(() => true, (a,b) => a.patientName.localeCompare(b.patientName), {
                    getTeams: (teams) => teams,
                    rules: { phase: 'general', relaxAvoid: false },
                    phaseName: 'General-StrictAvoid'
                });
                if (patientsToProcess.filter(p => assignedPatientIdsThisRun.has(p.id)).length > assignedPatientIdsThisRun.size) iterationNeeded = true; // Primitive check
            }

            if (patientsToProcess.some(p => !assignedPatientIdsThisRun.has(p.id))) {
                iterationNeeded = true;
                while(iterationNeeded && patientsToProcess.some(p => !assignedPatientIdsThisRun.has(p.id))) {
                    iterationNeeded = false;
                    runAssignmentPhase(() => true, (a,b) => a.patientName.localeCompare(b.patientName), {
                        getTeams: (teams) => teams,
                        rules: { phase: 'general', relaxAvoid: true },
                        phaseName: 'General-RelaxedAvoid'
                    });
                }
            }
            
            return { teamsWithAssignments: teamsCopy, newlyAssignedPatientsLog, remainingUnassigned: patientsToProcess.filter(p => !assignedPatientIdsThisRun.has(p.id)) };
        };

        const generateRoundRobin = (finalTeams, supportOptions) => {
            const activeSupportTeams = supportOptions.filter(opt => opt.selected && (opt.role === 'rounding' || opt.role === 'hybrid')).map(opt => {
                const finalTeamState = finalTeams.find(t => t.teamName === opt.name);
                if (!finalTeamState || finalTeamState.currentPatientsThisSession.length >= 10) return null;
                const startingPatients = opt.preSelectedPatients || [];
                const startingPatientIds = new Set(startingPatients.map(p => p.id));
                const newlyAssigned = finalTeamState.currentPatientsThisSession.filter(p => !startingPatientIds.has(p.originalPatientId));
                return { name: opt.name, emptySpots: 10 - finalTeamState.currentPatientsThisSession.length, score: (10 - finalTeamState.currentPatientsThisSession.length) - newlyAssigned.length - (2 * newlyAssigned.filter(p => p.needsHAndP).length) };
            }).filter(Boolean);

            if (activeSupportTeams.length === 0) return '';
            let roundRobinOrder = [];
            let tempTeams = JSON.parse(JSON.stringify(activeSupportTeams));
            while (tempTeams.some(t => t.emptySpots > 0)) {
                const eligibleTeams = tempTeams.filter(t => t.emptySpots > 0);
                if (eligibleTeams.length === 0) break;
                let bestTeam = eligibleTeams.reduce((best, current) => (current.score > best.score) ? current : best);
                roundRobinOrder.push(bestTeam.name);
                const teamIndex = tempTeams.findIndex(t => t.name === bestTeam.name);
                tempTeams[teamIndex].emptySpots -= 1;
                tempTeams[teamIndex].score -= 1;
            }
            return roundRobinOrder.join(' -> ');
        };

        const generateFinalLog = (finalTeams, initialPatients) => {
            const finalLog = [];
            const initialPatientMap = new Map(initialPatients.map(p => [p.id, p]));
            finalTeams.forEach(team => {
                team.currentPatientsThisSession.forEach(assignedPatient => {
                    const originalPatient = initialPatientMap.get(assignedPatient.originalPatientId);
                    if (originalPatient) finalLog.push({ ...originalPatient, id: assignedPatient.originalPatientId, assignedTeamName: team.teamName, phase: 'Final Assignment' });
                });
            });
            return finalLog;
        };

        // ==========================================
        // SECTION 3: SUB-COMPONENTS
        // ==========================================

        const TeamCard = ({ team, onUpdateLowCap, onUpdateStartCount, onUpdateOtherLocations, renderSummary }) => (
            <div className="border border-gray-200 rounded-md p-3 bg-blue-50 h-full">
                <div className="flex justify-between items-start">
                    <h3 className="text-lg font-bold text-blue-800">{team.teamName}</h3>
                    <label className="checkbox-label bg-yellow-100 px-2 py-1 rounded ml-2">
                        <input type="checkbox" checked={team.lowCap} onChange={(e) => onUpdateLowCap(team.id, e.target.checked)} /> Low Cap (10)
                    </label>
                </div>
                <div className="text-sm text-gray-700 my-1 flex items-center">
                    <label htmlFor={`startCount-${team.id}`} className="font-semibold mr-2">Starting Patients:</label>
                    <input type="number" id={`startCount-${team.id}`} defaultValue={team.startingPatientCount} onBlur={(e) => onUpdateStartCount(team.id, e.target.value)} className="compact-input" min="0"/>
                </div>
                <p className="text-xs text-gray-600"><span className="font-semibold">Pref. Locations:</span> {formatLocationsWithPriority(team.preferredLocations) || 'None'}</p>
                <div className="text-xs text-gray-600 flex items-center">
                    <span className="font-semibold mr-1">Other Locations:</span>
                    <input type="text" defaultValue={(team.otherLocations || []).join(', ')} onBlur={(e) => onUpdateOtherLocations(team.id, e.target.value)} className="ml-1 p-0.5 border border-gray-300 rounded text-xs flex-grow min-w-0" placeholder="e.g., G21, P7, ED" />
                </div>
                <p className="text-xs text-gray-600"><span className="font-semibold">Avoid Locations:</span> {(team.avoidLocations || []).join(', ') || 'None'}</p>
                <p className="text-xs text-gray-600"><span className="font-semibold">Gyn Preference:</span> {team.prefersGynPatients ? 'Yes' : 'No'}</p>
                <p className="text-xs text-gray-600"><span className="font-semibold">Sarcoma Preference:</span> {team.prefersSarcomaPatients ? 'Yes' : 'No'}</p>
                {team.otherPreferences && <p className="text-xs text-gray-600 mt-1 pt-1 border-t border-gray-300"><span className="font-semibold">Other Notes:</span> {team.otherPreferences}</p>}
                <p className="text-sm text-gray-700 mt-2 pt-1 border-t border-gray-300 font-semibold">Assigned (this session):</p>
                <div>{renderSummary(team)}</div>
            </div>
        );

        const PatientEntryForm = ({ onAddPatient }) => {
            const nameRef = useRef();
            const locRef = useRef();
            const admitRef = useRef();
            const [type, setType] = useState('None');
            const [hnp, setHnp] = useState(false);

            const handleSubmit = () => {
                onAddPatient(nameRef.current.value, locRef.current.value, admitRef.current.value, type, hnp);
                nameRef.current.value = ''; locRef.current.value = ''; admitRef.current.value = '';
                setType('None'); setHnp(false);
            };

            return (
                <div className="bg-white p-6 rounded-xl shadow-md mb-8">
                    <h2 className="text-2xl font-semibold text-blue-600 mb-4">Add New Unassigned Patient</h2>
                    <div className="grid grid-cols-1 md:grid-cols-5 gap-4 items-end">
                        <div className="md:col-span-2"> <label className="label-text">Patient Name:</label> <input type="text" ref={nameRef} className="input-field" placeholder="e.g., John Doe" /> </div>
                        <div> <label className="label-text">Current Location:</label> <input type="text" ref={locRef} className="input-field" placeholder="e.g., G21" /> </div>
                        <div> 
                            <label className="label-text">Patient Type:</label> 
                            <select value={type} onChange={e => setType(e.target.value)} className="input-field">
                                <option value="None">None</option>
                                <option value="Gyn">Gyn</option>
                                <option value="Sarcoma">Sarcoma</option>
                            </select>
                        </div>
                        <div className="flex items-center md:pt-6"> <input type="checkbox" checked={hnp} onChange={(e) => setHnp(e.target.checked)} className="h-5 w-5 mr-2"/> <label className="label-text mb-0">Needs H&P</label> </div>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-5 gap-4 mt-4">
                        <div className="md:col-span-2"> <label className="label-text">Admitting Team:</label> <input type="text" ref={admitRef} className="input-field" placeholder="e.g., M, D, Nocturnal, Backup" /> </div>
                        <div className="md:col-span-3 flex items-end"> <button onClick={handleSubmit} className="w-full btn-primary">Add Patient to Unassigned List</button> </div>
                    </div>
                </div>
            );
        };

        const UnassignedList = ({ patients, onDelete, onDeleteAll, loading }) => (
            <div className="bg-white p-6 rounded-xl shadow-md h-full">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-2xl font-semibold text-blue-600">Unassigned Patients ({patients.length})</h2>
                    <button onClick={onDeleteAll} className="btn-secondary btn-small-action" disabled={loading || patients.length === 0}>Del All</button>
                </div>
                {patients.length === 0 ? <p className="text-gray-500">No unassigned patients.</p> : ( 
                    <ul className="space-y-3 max-h-96 overflow-y-auto"> 
                        {patients.map(p => ( 
                            <li key={p.id} className="flex justify-between items-center border-b border-gray-200 pb-2 last:border-b-0"> 
                                <div> 
                                    <p className="font-medium text-gray-800">{p.patientName}</p> 
                                    <p className="text-sm text-gray-600">Loc: {p.currentLocation} {p.patientType && `(Type: ${p.patientType})`} {p.needsHAndP && <span className="font-semibold text-red-600">(Needs H&P)</span>}</p> 
                                    {p.admittingTeam && <p className="text-xs text-gray-500">Admitting: {p.admittingTeam}</p>} 
                                </div> 
                                <button onClick={() => onDelete(p.id, p.patientName)} className="btn-secondary btn-small-action">Del</button> 
                            </li> 
                        ))} 
                    </ul> 
                )}
            </div>
        );

        const AssignmentReport = ({ reportData }) => {
            if (!reportData || reportData.length === 0) return null;
            return (
                <div className="bg-green-50 p-6 rounded-xl shadow-md border border-green-200 mb-8">
                    <h2 className="text-2xl font-semibold text-green-700 mb-4">Assignment Report by Admitting Team</h2>
                    <div className="max-h-96 overflow-y-auto text-sm">
                        {reportData.reduce((acc, entry, index) => {
                            const prevEntry = reportData[index - 1];
                            if (!prevEntry || prevEntry.admittingTeam !== entry.admittingTeam) {
                                acc.push(<h3 key={`header-${entry.admittingTeam}`} className="text-lg font-semibold text-green-600 mt-3 mb-1 pt-2 border-t border-green-200 first:mt-0 first:border-t-0">Admitting Team: {entry.admittingTeam}</h3>);
                            }
                            acc.push(<p key={index} className="ml-4 text-gray-700"><span className="font-medium">{entry.patientName}</span> assigned to <span className="font-medium">{entry.assignedTeamName}</span> <span className="text-xs text-gray-500">({entry.phase})</span></p>);
                            return acc;
                        }, [])}
                    </div>
                </div>
            );
        };

        const TeamSummaryReport = ({ summaryData, admissionData }) => {
            if (!summaryData || summaryData.length === 0) return null;
            const supportTeamsSummary = summaryData.filter(s => s.isSupportTeam);
            const regularTeamsSummary = summaryData.filter(s => !s.isSupportTeam);

            return (
                <div className="bg-indigo-50 p-6 rounded-xl shadow-md border border-indigo-200 mb-8">
                    <h2 className="text-2xl font-semibold text-indigo-700 mb-4">Team Assignment Summary</h2>
                    <div className="max-h-96 overflow-y-auto text-sm">
                        {supportTeamsSummary.map(summary => <p key={summary.teamName} className="text-gray-700 mb-1"><span className="font-bold text-indigo-800">{summary.teamName}:</span> {summary.startingAmount} + {summary.newlyAssignedCount} = {summary.totalPatients}{summary.detailString}</p>)}
                        {admissionData && (
                            <React.Fragment>
                                <div className="h-4" />
                                <p className="font-semibold text-indigo-800">For admissions:</p>
                                <p className="text-gray-700 mb-1 ml-4"><span className="font-bold text-indigo-800">Teams:</span> {admissionData.teamNames.join(', ')}</p>
                                <p className="text-gray-700 mb-1 ml-4"><span className="font-bold text-indigo-800">Admission Capacity:</span> {admissionData.totalCapacity}</p>
                                {admissionData.roundRobinString && <p className="text-gray-700 mb-1 ml-4"><span className="font-bold text-indigo-800">Round Robin:</span> {admissionData.roundRobinString}</p>}
                            </React.Fragment>
                        )}
                        {supportTeamsSummary.length > 0 && <div className="h-4" />}
                        {regularTeamsSummary.map(summary => <p key={summary.teamName} className="text-gray-700 mb-1"><span className="font-bold text-indigo-800">{summary.teamName}:</span> {summary.startingAmount} + {summary.newlyAssignedCount} = {summary.totalPatients}{summary.detailString}</p>)}
                    </div>
                </div>
            );
        };

        const FastDataEntryModal = ({ show, onClose, onSubmit, loading }) => {
            const [teamData, setTeamData] = useState('');
            const [patientData, setPatientData] = useState('');
            if (!show) return null;
            return (
                <div className="modal-backdrop">
                    <div className="modal-content modal-content-large">
                        <h2 className="text-2xl font-semibold mb-4">Fast Data Entry</h2>
                        <div className="space-y-4 text-left">
                            <div>
                                <label className="label-text">Team Data</label>
                                <p className="text-xs text-gray-500 mb-1">Format: (TeamName; StartCount; OtherLoc1,OtherLoc2)</p>
                                <textarea value={teamData} onChange={(e) => setTeamData(e.target.value)} className="textarea-large" placeholder="(A;7;P4,P7,G21,ED)(B;12;G22,G21,G20)(C;14;G22,P7)"/>
                            </div>
                            <div>
                                <label className="label-text">Unassigned Patient Data</label>
                                <p className="text-xs text-gray-500 mb-1">Format: (AdmitTeam; PtName; Location; Gyn Y/N; Sarcoma Y/N; H&P Y/N) or (PtName; Location...)</p>
                                <textarea value={patientData} onChange={(e) => setPatientData(e.target.value)} className="textarea-large" placeholder="(M;G22A;G22;N;N;Y)(G22B;G22;N;N;N)(D;G7A;G7;N;Y;N)"/>
                            </div>
                        </div>
                        <div className="mt-6 flex justify-end space-x-4">
                            <button onClick={onClose} className="btn-neutral">Cancel</button>
                            <button onClick={() => onSubmit(teamData, patientData)} className="btn-primary" disabled={loading}>{loading ? 'Processing...' : 'Submit Data'}</button>
                        </div>
                    </div>
                </div>
            );
        };

        // ==========================================
        // SECTION 4: MAIN APP COMPONENT
        // ==========================================

        const App = () => {
            // State
            const [teams, setTeams] = useState(() => JSON.parse(JSON.stringify(defaultTeamDataArray)).map(t => ({...t, id: generateUUID(), currentPatients: t.currentPatients || [] })));
            const [unassignedPatients, setUnassignedPatients] = useState([]);
            const [assignmentReportData, setAssignmentReportData] = useState([]);
            const [teamAssignmentSummaryData, setTeamAssignmentSummaryData] = useState([]);
            const [admissionSummaryData, setAdmissionSummaryData] = useState(null);
            const [loading, setLoading] = useState(false);
            
            // History & Flags
            const [previousTeamsState, setPreviousTeamsState] = useState(null);
            const [previousUnassignedPatientsState, setPreviousUnassignedPatientsState] = useState(null);
            const [assignmentPerformedInSession, setAssignmentPerformedInSession] = useState(false);

            // Modals State
            const [showGeneralModal, setShowGeneralModal] = useState(false);
            const [generalModalMessage, setGeneralModalMessage] = useState('');
            const [generalModalConfirmAction, setGeneralModalConfirmAction] = useState(null);
            const [generalModalContent, setGeneralModalContent] = useState(null);
            const [showOverCapModal, setShowOverCapModal] = useState(false);
            const [overCapPatients, setOverCapPatients] = useState([]);
            const [showFastDataEntryModal, setShowFastDataEntryModal] = useState(false);
            const [showEditTeamsModal, setShowEditTeamsModal] = useState(false);
            const [editingTeamInMainModal, setEditingTeamInMainModal] = useState(initialTeamFormState);
            const [isEditingExistingTeamInMainModal, setIsEditingExistingTeamInMainModal] = useState(false);
            const [sessionDefaultTeams, setSessionDefaultTeams] = useState(() => JSON.parse(JSON.stringify(defaultTeamDataArray)).map(t => ({...t, id: generateUUID()})));
            const [showEditDefaultTeamsModal, setShowEditDefaultTeamsModal] = useState(false);
            const [editingSingleDefaultTeam, setEditingSingleDefaultTeam] = useState(null);

            // Helpers
            const displayGeneralModal = (message, action = null, content = null) => {
                setGeneralModalMessage(message); setGeneralModalConfirmAction(action ? () => action : null); setGeneralModalContent(content); setShowGeneralModal(true);
            };

            // Actions - Teams
            const handleStartingPatientCountChange = (teamId, val) => {
                const newCount = parseInt(val, 10);
                if (!isNaN(newCount) && newCount >= 0) setTeams(prev => prev.map(t => t.id === teamId ? { ...t, startingPatientCount: newCount } : t));
            };
            const handleLowCapChange = (teamId, checked) => setTeams(prev => prev.map(t => t.id === teamId ? { ...t, lowCap: checked } : t));
            const handleOtherLocationsChange = (teamId, val) => setTeams(prev => prev.map(t => t.id === teamId ? { ...t, otherLocations: val.split(',').map(s=>s.trim()).filter(Boolean) } : t));
            
            const _loadDefaultTeamsData = () => {
                setTeams(JSON.parse(JSON.stringify(sessionDefaultTeams)).map(t => ({...t, id: generateUUID(), currentPatients: [] })));
                setAssignmentPerformedInSession(false); setAssignmentReportData([]); setTeamAssignmentSummaryData([]);
                return true;
            };
            const handleResetTeams = () => {
                displayGeneralModal("Are you sure you want to reset all teams? Current assignments will be cleared.", () => {
                    setTeams(prev => prev.map(t => ({ ...t, currentPatients: [] })));
                    setAssignmentPerformedInSession(false); setPreviousTeamsState(null); setPreviousUnassignedPatientsState(null); setAssignmentReportData([]); setTeamAssignmentSummaryData([]); setAdmissionSummaryData(null);
                    displayGeneralModal("Teams reset.");
                });
            };

            // Actions - Patients
            const addPatient = (name, loc, admit, type, hnp) => {
                if (!name || !loc) { displayGeneralModal("Name and Location required."); return; }
                setUnassignedPatients(prev => [...prev, { id: generateUUID(), patientName: name, currentLocation: loc, admittingTeam: admit || 'N/A', patientType: type === 'None' ? '' : type, needsHAndP: hnp }]);
                displayGeneralModal(`Patient "${name}" added.`);
            };
            const deleteUnassignedPatient = (id, name) => { setUnassignedPatients(prev => prev.filter(p => p.id !== id)); displayGeneralModal(`Patient "${name}" deleted.`); };
            const deleteAllUnassignedPatients = () => {
                if (unassignedPatients.length === 0) return;
                displayGeneralModal("Delete ALL unassigned patients?", () => { setUnassignedPatients([]); displayGeneralModal("All deleted."); });
            };

            // Actions - Fast Data
            const handleFastDataSubmit = (teamDataStr, patientDataStr) => {
                setLoading(true);
                try {
                    let newTeams = JSON.parse(JSON.stringify(teams));
                    let newPatients = [...unassignedPatients];
                    let updates = false;

                    // Process Teams
                    const teamEntries = teamDataStr.trim().match(/\((.*?)\)/g);
                    if (teamEntries) {
                        teamEntries.forEach(entry => {
                            const content = entry.slice(1, -1);
                            const idx = content.indexOf(';');
                            if (idx === -1) return;
                            const name = content.substring(0, idx).trim();
                            const rest = content.substring(idx + 1).trim();
                            const numMatch = rest.match(/^(\d+)/);
                            if (!numMatch) return;
                            const count = parseInt(numMatch[0], 10);
                            const locs = rest.substring(numMatch[0].length).replace(/^[,;]/, '').split(',').map(s => s.trim()).filter(Boolean);
                            
                            const tIndex = newTeams.findIndex(t => t.teamName.toLowerCase() === name.toLowerCase());
                            if (tIndex !== -1) { newTeams[tIndex].startingPatientCount = count; newTeams[tIndex].otherLocations = locs; updates = true; }
                        });
                    }

                    // Process Patients
                    const patEntries = patientDataStr.trim().match(/\((.*?)\)/g);
                    if (patEntries) {
                        patEntries.forEach(entry => {
                            const parts = entry.slice(1, -1).split(/[;:]/).map(p => p.trim());
                            let admit, name, loc, gyn, sarc, hnp;
                            if (parts.length === 6) [admit, name, loc, gyn, sarc, hnp] = parts;
                            else if (parts.length === 5) { admit = 'N/A'; [name, loc, gyn, sarc, hnp] = parts; }
                            else return;
                            if (!name || !loc) return;
                            let type = ''; if (sarc.toUpperCase() === 'Y') type = 'Sarcoma'; else if (gyn.toUpperCase() === 'Y') type = 'Gyn';
                            newPatients.push({ id: generateUUID(), admittingTeam: admit, patientName: name, currentLocation: loc, patientType: type, needsHAndP: hnp.toUpperCase() === 'Y' });
                            updates = true;
                        });
                    }

                    if (updates) { setTeams(newTeams); setUnassignedPatients(newPatients); displayGeneralModal("Fast entry successful."); }
                    else displayGeneralModal("No data processed.");
                    setShowFastDataEntryModal(false);
                } catch (e) { displayGeneralModal("Error parsing data."); }
                setLoading(false);
            };

            // Actions - Assignment
            const performAssignment = (teamsToUse, patientsToUse, supportOptions = null) => {
                const result = assignPatientsLogic(teamsToUse, patientsToUse);
                let finalTeams = result.teamsWithAssignments;
                
                // Post-processing phases
                if (finalTeams.length > 0) {
                    finalTeams = fillUnderutilizedTeamsPhase(finalTeams);
                    finalTeams = equalizeFinalCountsPhase(finalTeams);
                    finalTeams = balanceNewPatientWorkloadPhase(finalTeams);
                    finalTeams = swapPhaseLogic(finalTeams);
                }

                const log = generateFinalLog(finalTeams, patientsToUse);
                
                // Finalize
                const report = log.map(l => ({ admittingTeam: l.admittingTeam || 'N/A', patientName: l.patientName, assignedTeamName: l.assignedTeamName, phase: l.phase })).sort((a,b) => a.admittingTeam.localeCompare(b.admittingTeam) || a.assignedTeamName.localeCompare(b.assignedTeamName));
                setAssignmentReportData(report);

                let admSummary = null;
                if (supportOptions) {
                    const admittingOpts = supportOptions.filter(o => o.selected && (o.role === 'admitting' || o.role === 'hybrid'));
                    if (admittingOpts.length > 0) {
                        let capacity = 0;
                        admittingOpts.forEach(o => {
                            const t = finalTeams.find(ft => ft.teamName === o.name);
                            capacity += t ? (10 - t.currentPatientsThisSession.length) : (10 - (o.startCount || 0));
                        });
                        admSummary = { teamNames: admittingOpts.map(o => o.name), totalCapacity: capacity, roundRobinString: generateRoundRobin(finalTeams, supportOptions) };
                    }
                }
                setAdmissionSummaryData(admSummary);

                const summary = finalTeams.map(t => {
                    const newly = supportTeamOrder.includes(t.teamName) ? t.currentPatientsThisSession.length - (t.startingPatientCount||0) : t.currentPatientsThisSession.length;
                    const hnpList = t.currentPatientsThisSession.filter(p=>p.needsHAndP);
                    const detail = hnpList.length > 0 ? `, needs H&P: ${hnpList.length} (${hnpList.map(p=>p.name).join(', ')})` : '';
                    return { teamName: t.teamName, startingAmount: t.startingPatientCount||0, newlyAssignedCount: newly, totalPatients: (t.startingPatientCount||0)+newly, detailString: detail, isSupportTeam: supportTeamOrder.includes(t.teamName) };
                }).sort((a,b) => a.teamName.localeCompare(b.teamName));
                setTeamAssignmentSummaryData(summary);

                const originalTeamIds = new Set(teams.map(t => t.id));
                setTeams(prev => prev.map(t => {
                    const ft = finalTeams.find(f => f.id === t.id);
                    if (ft && originalTeamIds.has(t.id)) return { ...t, currentPatients: ft.currentPatientsThisSession.map(p => ({ name: p.name, location: p.location, type: p.type, needsHAndP: p.needsHAndP })) };
                    return t;
                }));
                
                const assignedIds = new Set(log.map(p => p.id));
                const remaining = result.remainingUnassigned;
                setUnassignedPatients(prev => prev.filter(p => !assignedIds.has(p.id)));

                setAssignmentPerformedInSession(true);
                if (remaining.length > 0) {
                    const allCapped = finalTeams.every(t => (t.startingPatientCount + t.currentPatientsThisSession.length) >= (t.lowCap?10:16));
                    if (allCapped) { setOverCapPatients(remaining); setShowOverCapModal(true); }
                    else displayGeneralModal("Assignment complete. Some patients unassigned.", null, <ul>{remaining.map(p => <li key={p.id}>{p.patientName}</li>)}</ul>);
                } else {
                    displayGeneralModal("All patients assigned!");
                }
            };

            const assignPatients = () => {
                if (teams.length === 0 || unassignedPatients.length === 0) return;
                setLoading(true); setAdmissionSummaryData(null);
                setPreviousTeamsState(JSON.parse(JSON.stringify(teams)));
                setPreviousUnassignedPatientsState(JSON.parse(JSON.stringify(unassignedPatients)));
                performAssignment(JSON.parse(JSON.stringify(teams)), JSON.parse(JSON.stringify(unassignedPatients)));
                setLoading(false);
            };

            const handleReassignWithSupport = (supportOptions, overcapTeams) => {
                setShowOverCapModal(false); setLoading(true);
                let teamsRun = JSON.parse(JSON.stringify(previousTeamsState));
                let patientsRun = JSON.parse(JSON.stringify(previousUnassignedPatientsState));
                
                if (overcapTeams) {
                    const targetNames = new Set(['A','B','C','E','F','G','H','I','J','K','L','N','O','P']);
                    teamsRun.forEach(t => { if(targetNames.has(t.teamName)) t.cap = (t.lowCap?10:16)+1; });
                }

                const preSelIds = new Set(supportOptions.flatMap(o => (o.preSelectedPatients||[]).map(p=>p.id)));
                const mainPatients = patientsRun.filter(p => !preSelIds.has(p.id));

                // Create Support Teams
                const supportTeams = supportOptions.filter(o => o.selected).map((o, i) => {
                    const preSel = (o.preSelectedPatients||[]).map(p => ({ name: p.patientName, location: p.currentLocation, type: p.patientType||'', needsHAndP: p.needsHAndP||false, originalPatientId: p.id }));
                    return {
                        id: `support-${o.name.replace(/\s+/g,'-')}-${i}`, teamName: o.name, startingPatientCount: preSel.length, preferredLocations: [], otherLocations: [], avoidLocations: [], prefersGynPatients: false, prefersSarcomaPatients: false, currentPatients: [], lowCap: true, cap: 10,
                        currentPatientsThisSession: preSel, currentLoad: preSel.reduce((s,p)=>s+(p.needsHAndP?2:1),0), needsHAndPThisSessionCount: preSel.filter(p=>p.needsHAndP).length, newPatientsThisSessionCount: preSel.length
                    };
                });

                // 1. Assign Main
                const mainRes = assignPatientsLogic(teamsRun, mainPatients);
                let mainTeams = mainRes.teamsWithAssignments;
                // Optimization
                if(mainTeams.length>0) { mainTeams = fillUnderutilizedTeamsPhase(mainTeams); mainTeams = equalizeFinalCountsPhase(mainTeams); mainTeams = balanceNewPatientWorkloadPhase(mainTeams); mainTeams = swapPhaseLogic(mainTeams); }
                
                // 2. Assign Support
                const roundingNames = new Set(supportOptions.filter(o => o.selected && (o.role==='rounding' || o.role==='hybrid')).map(o=>o.name));
                const roundTeams = supportTeams.filter(t => roundingNames.has(t.teamName));
                const suppRes = assignPatientsLogic(roundTeams, mainRes.remainingUnassigned);
                
                const finalSupport = supportTeams.map(t => suppRes.teamsWithAssignments.find(st=>st.id===t.id) || t);
                const finalAll = [...mainTeams, ...finalSupport];

                // Finalize
                const log = generateFinalLog(finalAll, patientsRun);
                // Reuse finalization logic slightly modified (manually called)
                const report = log.map(l => ({ admittingTeam: l.admittingTeam || 'N/A', patientName: l.patientName, assignedTeamName: l.assignedTeamName, phase: l.phase })).sort((a,b) => a.admittingTeam.localeCompare(b.admittingTeam) || a.assignedTeamName.localeCompare(b.assignedTeamName));
                setAssignmentReportData(report);
                
                let admSummary = null;
                const admittingOpts = supportOptions.filter(o => o.selected && (o.role === 'admitting' || o.role === 'hybrid'));
                if (admittingOpts.length > 0) {
                    let capacity = 0;
                    admittingOpts.forEach(o => {
                        const t = finalAll.find(ft => ft.teamName === o.name);
                        capacity += t ? (10 - t.currentPatientsThisSession.length) : (10 - (o.startCount || 0));
                    });
                    admSummary = { teamNames: admittingOpts.map(o => o.name), totalCapacity: capacity, roundRobinString: generateRoundRobin(finalAll, supportOptions) };
                }
                setAdmissionSummaryData(admSummary);

                const summary = finalAll.map(t => {
                    const newly = supportTeamOrder.includes(t.teamName) ? t.currentPatientsThisSession.length - (t.startingPatientCount||0) : t.currentPatientsThisSession.length;
                    const hnpList = t.currentPatientsThisSession.filter(p=>p.needsHAndP);
                    const detail = hnpList.length > 0 ? `, needs H&P: ${hnpList.length} (${hnpList.map(p=>p.name).join(', ')})` : '';
                    return { teamName: t.teamName, startingAmount: t.startingPatientCount||0, newlyAssignedCount: newly, totalPatients: (t.startingPatientCount||0)+newly, detailString: detail, isSupportTeam: supportTeamOrder.includes(t.teamName) };
                }).sort((a,b) => a.teamName.localeCompare(b.teamName));
                setTeamAssignmentSummaryData(summary);

                const originalTeamIds = new Set(teams.map(t => t.id));
                setTeams(prev => prev.map(t => {
                    const ft = finalAll.find(f => f.id === t.id);
                    if (ft && originalTeamIds.has(t.id)) return { ...t, currentPatients: ft.currentPatientsThisSession.map(p => ({ name: p.name, location: p.location, type: p.type, needsHAndP: p.needsHAndP })) };
                    return t;
                }));
                
                const assignedIds = new Set(log.map(p => p.id));
                setUnassignedPatients(prev => prev.filter(p => !assignedIds.has(p.id)));
                setAssignmentPerformedInSession(true);
                const remaining = suppRes.remainingUnassigned;
                if (remaining.length > 0) displayGeneralModal("Assignment with support complete. Some patients still unassigned.", null, <ul>{remaining.map(p => <li key={p.id}>{p.patientName}</li>)}</ul>);
                else displayGeneralModal("All patients assigned with support!");
                setLoading(false);
            };

            const handleUndoAssignment = () => {
                if (!previousTeamsState || !previousUnassignedPatientsState) return;
                setTeams(previousTeamsState); setUnassignedPatients(previousUnassignedPatientsState);
                setAssignmentPerformedInSession(false); setPreviousTeamsState(null); setPreviousUnassignedPatientsState(null); setAssignmentReportData([]); setTeamAssignmentSummaryData([]); setAdmissionSummaryData(null);
                displayGeneralModal("Undo successful.");
            };

            // Render Helpers
            const renderTeamSummary = (team) => {
                const pts = team.currentPatients || [];
                const start = team.startingPatientCount || 0;
                if (pts.length === 0) return <React.Fragment><p className="text-sm text-gray-600">None</p><p className="text-sm text-gray-800 font-mono">{start} + 0 = {start}</p></React.Fragment>;
                const hnp = pts.filter(p=>p.needsHAndP); const fu = pts.filter(p=>!p.needsHAndP);
                const parts = []; if(fu.length>0) parts.push(`${fu.length} F/U`); if(hnp.length>0) parts.push(`${hnp.length} H&P`);
                return <React.Fragment><p className="text-sm text-gray-600">{pts.length} total: {parts.join(', ')}</p><p className="text-sm text-gray-800 font-mono mt-1">{start} + {pts.length} = {start+pts.length}</p></React.Fragment>;
            };

            return (
                <div className="container mx-auto max-w-7xl">
                    <h1 className="text-4xl font-bold text-center text-blue-700 mb-6 mt-6">Medical Team Patient Assignment</h1>
                    <p className="text-center text-xs text-gray-500 mb-6">Modular Version</p>

                    <div className="bg-white p-6 rounded-xl shadow-md mb-8">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-2xl font-semibold text-blue-600">Current Teams ({teams.length})</h2>
                            <div className="space-x-2">
                                <button onClick={() => setShowFastDataEntryModal(true)} className="btn-neutral">Fast Data Entry</button>
                                <button onClick={handleResetTeams} className="btn-secondary" disabled={loading || teams.length === 0}>Reset Teams</button>
                                <button onClick={() => displayGeneralModal("Edit/Add Teams functionality simplified for this demo.", null)} className="btn-primary">Edit/Add Teams</button>
                            </div>
                        </div>
                        {teams.length === 0 && !loading ? <p className="text-gray-500">No teams loaded.</p> : (
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                                {teams.map(team => <TeamCard key={team.id} team={team} onUpdateLowCap={handleLowCapChange} onUpdateStartCount={handleStartingPatientCountChange} onUpdateOtherLocations={handleOtherLocationsChange} renderSummary={renderTeamSummary} />)}
                            </div>
                        )}
                    </div>

                    <PatientEntryForm onAddPatient={addPatient} />

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                        <UnassignedList patients={unassignedPatients} onDelete={deleteUnassignedPatient} onDeleteAll={deleteAllUnassignedPatients} loading={loading} />
                        <div className="bg-white p-6 rounded-xl shadow-md text-center flex flex-col justify-center space-y-4">
                            <button onClick={assignPatients} className="w-full btn-primary text-xl py-3" disabled={loading || teams.length === 0 || unassignedPatients.length === 0}> {loading ? 'Processing...' : 'Assign Unassigned Patients'} </button>
                            <button onClick={handleUndoAssignment} className="w-full btn-neutral text-lg py-2" disabled={loading || !assignmentPerformedInSession}> Undo Assignment </button>
                        </div>
                    </div>

                    <AssignmentReport reportData={assignmentReportData} />
                    <TeamSummaryReport summaryData={teamAssignmentSummaryData} admissionData={admissionSummaryData} />

                    {/* Modals */}
                    {showGeneralModal && (
                        <div className="modal-backdrop">
                            <div className="modal-content">
                                <p className="text-lg font-medium mb-4 whitespace-pre-wrap">{generalModalMessage}</p>
                                {generalModalContent && <div className="mb-6 text-left">{generalModalContent}</div>}
                                <div className="flex justify-center space-x-4">
                                    {generalModalConfirmAction ? <React.Fragment><button onClick={() => {generalModalConfirmAction(); setShowGeneralModal(false);}} className="btn-primary">Confirm</button><button onClick={() => setShowGeneralModal(false)} className="btn-neutral">Cancel</button></React.Fragment> : <button onClick={() => setShowGeneralModal(false)} className="btn-primary">OK</button>}
                                </div>
                            </div>
                        </div>
                    )}
                    <OverCapModal show={showOverCapModal} patients={overCapPatients} allOriginalUnassigned={previousUnassignedPatientsState} onClose={() => setShowOverCapModal(false)} onReassign={handleReassignWithSupport} />
                    <FastDataEntryModal show={showFastDataEntryModal} onClose={() => setShowFastDataEntryModal(false)} onSubmit={handleFastDataSubmit} loading={loading} />
                </div>
            );
        };

        // ==========================================
        // SECTION 5: MODAL COMPONENTS (Existing)
        // ==========================================

        const StartingPatientsModal = ({ show, patients, teamName, onSave, onClose, previouslySelectedIds, allPreSelectedPatients }) => {
            const [selectedIds, setSelectedIds] = useState(new Set(previouslySelectedIds));
            useEffect(() => { setSelectedIds(new Set(previouslySelectedIds)); }, [show, previouslySelectedIds]);
            if (!show) return null;
            
            const sortedPatients = [...patients].sort((a, b) => (a.admittingTeam || 'Z').localeCompare(b.admittingTeam || 'Z') || a.patientName.localeCompare(b.patientName) || (a.currentLocation || '').localeCompare(b.currentLocation || ''));
            const handleSelect = (pid) => {
                const newSet = new Set(selectedIds);
                if (newSet.has(pid)) newSet.delete(pid);
                else { if (selectedIds.size < 10) newSet.add(pid); else alert(`Max 10 patients.`); }
                setSelectedIds(newSet);
            };

            return (
                <div className="modal-backdrop" style={{ zIndex: 60 }}>
                    <div className="modal-content modal-content-large">
                        <h2 className="text-2xl font-semibold mb-2">Select Starting Patients for {teamName}</h2>
                        <div className="text-left bg-gray-50 p-3 rounded-md max-h-80 overflow-y-auto">
                            {sortedPatients.reduce((acc, p, i) => {
                                const prev = sortedPatients[i-1];
                                if (!prev || prev.admittingTeam !== p.admittingTeam) acc.push(<h3 key={`h-${p.id}`} className="font-bold bg-gray-200 p-1 rounded my-2 text-sm">Admitting: {p.admittingTeam || 'N/A'}</h3>);
                                const selInfo = allPreSelectedPatients.find(x => x.patientId === p.id);
                                const otherSel = selInfo && selInfo.teamName !== teamName;
                                acc.push(
                                    <label key={p.id} className={`flex items-center p-2 rounded ${otherSel ? 'opacity-50' : 'hover:bg-blue-100'}`}>
                                        <input type="checkbox" checked={selectedIds.has(p.id)} onChange={() => handleSelect(p.id)} disabled={otherSel} className="h-4 w-4 mr-3"/>
                                        {p.patientName} ({p.currentLocation}) {otherSel && <span className="text-xs text-red-600 italic">[taken by {selInfo.teamName}]</span>}
                                    </label>
                                );
                                return acc;
                            }, [])}
                        </div>
                        <div className="mt-6 flex justify-end space-x-4"><button onClick={onClose} className="btn-neutral">Cancel</button><button onClick={() => onSave(sortedPatients.filter(p => selectedIds.has(p.id)))} className="btn-primary">Save</button></div>
                    </div>
                </div>
            );
        };

        const OverCapModal = ({ show, patients, onClose, onReassign, allOriginalUnassigned }) => {
            const [supportOptions, setSupportOptions] = useState([
                { name: 'Team M', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
                { name: 'Backup 1', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
                { name: 'Backup 2', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
                { name: 'Backup 3', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
                { name: 'Moonlighter 1', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
                { name: 'Moonlighter 2', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
                { name: 'Moonlighter 3', selected: false, role: null, startCount: 0, preSelectedPatients: [] },
            ]);
            const [overcapTeams, setOvercapTeams] = useState(false);
            const [showStartingPatientsModal, setShowStartingPatientsModal] = useState(false);
            const [modalContextIndex, setModalContextIndex] = useState(null);

            useEffect(() => { if(show) { setSupportOptions(prev=>prev.map(o=>({...o, selected:false, role:null, startCount:0, preSelectedPatients:[]}))); setOvercapTeams(false); } }, [show]);
            if (!show) return null;

            const toggleOpt = (i) => setSupportOptions(prev => prev.map((o, idx) => idx===i ? { ...o, selected: !o.selected, role: !o.selected?null:o.role, startCount: !o.selected?0:o.startCount, preSelectedPatients: !o.selected?[]:o.preSelectedPatients } : o));
            const setRole = (i, r) => setSupportOptions(prev => prev.map((o, idx) => idx===i ? { ...o, role: o.role===r?null:r } : o));
            const handleSavePatients = (pats) => {
                setSupportOptions(prev => prev.map((o, idx) => idx===modalContextIndex ? { ...o, preSelectedPatients: pats, startCount: pats.length } : o));
                setShowStartingPatientsModal(false);
            };

            const allPre = supportOptions.flatMap(o => (o.preSelectedPatients||[]).map(p => ({ patientId: p.id, teamName: o.name })));

            return (
                <React.Fragment>
                    <div className="modal-backdrop">
                        <div className="modal-content modal-content-large">
                            <h2 className="text-2xl font-semibold mb-4">Additional Support Needed</h2>
                            <div className="text-left mb-4 bg-gray-50 p-3 rounded-md">
                                <h3 className="font-semibold text-lg">Unassigned Patients ({patients.length})</h3>
                                <ul className="text-sm list-disc list-inside max-h-24 overflow-y-auto">{patients.map(p => <li key={p.id}>{p.patientName}</li>)}</ul>
                            </div>
                            <div className="text-left space-y-1 text-sm">
                                <div className="grid grid-cols-[2fr,1fr,1fr,1fr,1fr] gap-2 font-bold text-gray-700 px-2 pb-1 border-b"><div>Option</div><div className="text-center">Round</div><div className="text-center">Admit</div><div className="text-center">Hybrid</div><div className="text-center">Start Pts</div></div>
                                {supportOptions.map((opt, i) => (
                                    <div key={opt.name} className="grid grid-cols-[2fr,1fr,1fr,1fr,1fr] gap-2 items-center p-2">
                                        <label className="flex items-center font-medium"><input type="checkbox" checked={opt.selected} onChange={() => toggleOpt(i)} className="mr-2"/>{opt.name}</label>
                                        <div className="text-center"><input type="checkbox" checked={opt.role==='rounding'} onChange={() => setRole(i,'rounding')} disabled={!opt.selected}/></div>
                                        <div className="text-center"><input type="checkbox" checked={opt.role==='admitting'} onChange={() => setRole(i,'admitting')} disabled={!opt.selected}/></div>
                                        <div className="text-center"><input type="checkbox" checked={opt.role==='hybrid'} onChange={() => setRole(i,'hybrid')} disabled={!opt.selected}/></div>
                                        <div className="text-center"><button onClick={() => { setModalContextIndex(i); setShowStartingPatientsModal(true); }} disabled={!opt.selected} className="text-blue-600 hover:underline disabled:text-gray-400">{opt.preSelectedPatients.length>0 ? `${opt.preSelectedPatients.length} Pts` : 'Select'}</button></div>
                                    </div>
                                ))}
                                <div className="pt-2 mt-2 border-t"><label className="flex items-center font-medium p-2"><input type="checkbox" checked={overcapTeams} onChange={() => setOvercapTeams(!overcapTeams)} className="mr-2"/> Overcap rounding teams by 1</label></div>
                            </div>
                            <div className="mt-6 flex justify-end space-x-4"><button onClick={onClose} className="btn-neutral">Cancel</button><button onClick={() => onReassign(supportOptions, overcapTeams)} className="btn-primary">Re-assign</button></div>
                        </div>
                    </div>
                    {showStartingPatientsModal && <StartingPatientsModal show={true} patients={allOriginalUnassigned||[]} teamName={supportOptions[modalContextIndex].name} previouslySelectedIds={(supportOptions[modalContextIndex].preSelectedPatients||[]).map(p=>p.id)} allPreSelectedPatients={allPre} onSave={handleSavePatients} onClose={()=>setShowStartingPatientsModal(false)} />}
                </React.Fragment>
            );
        };

        // Mount the App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>